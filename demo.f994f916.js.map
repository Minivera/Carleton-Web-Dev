{"mappings":"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","sources":["src/project/vdom/nodes/htmlNode.js","src/project/vdom/nodes/textNode.js","src/project/vdom/nodes/treeNode.js","src/project/vdom/context/applyContext.js","src/project/vdom/diffing/patchTree.js","src/project/vdom/tree/component.js","src/project/vdom/utils/flattenArray.js","src/project/vdom/nodes/factory.js","node_modules/classnames/index.js","src/project/demo/components/footer.jsx","/home/runner/work/carleton-web-dev/carleton-web-dev/node_modules/@parcel/scope-hoisting/lib/helpers.js","src/project/demo/components/todoItem.jsx","src/project/demo/model/todoModel.js","src/project/demo/index.jsx","src/project/vdom/index.js","src/project/demo/components/app.jsx"],"names":["HtmlNode","_ref","tag","attributes","children","$c483bf5af8290f2cd662c50f1336bd$var$_classCallCheck","this","domNode","other","Object","entries","find","_ref2","_ref3","$c483bf5af8290f2cd662c50f1336bd$var$_slicedToArray","key","value","length","TextNode","text","$ab51a5e78fa39f5c0b7d5925fb737f05$var$_classCallCheck","TreeNode","component","factory","$a34c81a8396481576d56101484e55d4$var$_classCallCheck","contextObjects","forEach","contextBuilder","Error","concat","$e4434fb8e96453685c35193d5b4f87bf$var$_typeof","contextObj","prototype","hasOwnProperty","call","previousCreator","contextCreator","context","apply","bind","$a34c81a8396481576d56101484e55d4$var$_slicedToArray","applyAttributes","oldAttributes","arguments","undefined","newAttributes","node","keys","removeAttribute","$f6663bccd22350ea64877355572b61e2$var$_slicedToArray","setAttribute","generateNode","virtualNode","$c483bf5af8290f2cd662c50f1336bd$export$HtmlNode","document","createElement","$ab51a5e78fa39f5c0b7d5925fb737f05$export$TextNode","createTextNode","$a34c81a8396481576d56101484e55d4$export$TreeNode","rootElement","setAll","patch","parent","oldNode","newNode","child","appendChild","map","replaceChild","diff","nodeValue","updateNode","update","oldChildrenQueue","$f6663bccd22350ea64877355572b61e2$var$_toConsumableArray","reverse","newChildrenQueue","index","oldChild","pop","slice","removeChild","newChild","_loop","push","ComponentElement","window","HTMLElement","_this","$bd7c0fa29be02bde8091569334a2372a$var$_classCallCheck","_super","mounted","props","virtualChild","setState","requestUpdate","lifecycleListeners","afterConnect","beforeMount","afterMount","beforeUpdate","shouldUpdate","afterUpdate","beforeDisconnect","tree","applyContext","mount","_this2","finalContext","$bd7c0fa29be02bde8091569334a2372a$var$_objectSpread","hook","listen","listener","render","$f6663bccd22350ea64877355572b61e2$export$patch","vtree","customElements","define","flatten","input","stack","$b4004002b7d326e5c6469a6a5b468$var$_toConsumableArray","res","next","Array","isArray","vdonizeChildren","createNode","_len","_key","flatChildren","$b4004002b7d326e5c6469a6a5b468$export$flatten","cloned","assign","hasOwn","classNames","classes","i","arg","argType","inner","join","$dc5118610df5cc910ea040e1de8e$exports","default","a","__esModule","Footer","count","completedCount","nowShowing","setNowShowing","clearCompleted","activeTodoWord","clearButton","$efe9a6cdc457f0954e90dd2137a671e0$export$createNode","class","onclick","$dc5118610df5cc910ea040e1de8e$$interop$default","selected","TodoItem","todo","model","_ref2$isEditing","isEditing","_ref2$editTodo","editTodo","title","setIsEditing","val","setEditTodo","handleSubmit","trim","id","completed","editing","type","checked","onchange","toggle","ondblclick","removeTodo","onblur","oninput","event","target","onkeydown","preventDefault","currentId","root","renderInto","element","_","_ref$todos","todos","_ref$newTodo","newTodo","_ref$nowShowing","setNewTodo","setTodos","addTodo","newTitle","$b9d57fa8a5c1de4aab41f5e867bd$var$_objectSpread","filter","all","$b9d57fa8a5c1de4aab41f5e867bd$var$_toConsumableArray","toggleAll","$b9d57fa8a5c1de4aab41f5e867bd$export$default","allTodos","shownTodos","activeTodoCount","reduce","accum","placeholder","autoFocus","htmlFor","$a4640d8033a36054353575a1596c$export$TodoItem","$aaa9c2a41b10e743c5ff0e575e69d19$export$Footer","querySelector"],"version":3,"file":"demo.f994f916.js.map","sourcesContent":["/**\n * HTML node class that manages an HTML element in the virtual Tree.\n * @todo Support SVGs\n * @export\n * @class HtmlNode\n */\nexport class HtmlNode {\n  /**\n   * Class constructor that stores the values.\n   * @param {Object} props - The properties given to this constructor.\n   * @param {String} props.tag - Tag name to create in the DOM when this node is mounted.\n   * @param {object} props.attributes - Attributes to assign to the HTML node when created.\n   * @param {(TreeNode|HtmlNode|TextNode)[]} props.children - The children to assign to the HTML node when created.\n   */\n  constructor({ tag, attributes, children }) {\n    /**\n     * Tag for creating the HTMLElement in the DOM when mounting.\n     * @type {String}\n     */\n    this.tag = tag;\n\n    /**\n     * Attributes to assign to the HTMLElement when mounting or updating.\n     * @type {Object}\n     */\n    this.attributes = attributes;\n\n    /**\n     * Virtual children that will have to be patched into the virtual DOM node when mounting or updating.\n     * @type {(TreeNode|HtmlNode|TextNode)[]}\n     */\n    this.children = children;\n\n    /**\n     * DOM node assigned to this virtual node for easy access.\n     * @type {HTMLElement}\n     */\n    this.domNode = null;\n  }\n\n  /**\n   * Diffing function that returns if the two nodes are the same or not.\n   * @param other {TreeNode|HtmlNode|TextNode}\n   * @returns {boolean} Returns true if the two nodes are the same, false otherwise.\n   */\n  diff(other) {\n    if (!(other instanceof HtmlNode)) {\n      return false;\n    }\n    if (this.tag !== other.tag) {\n      return false;\n    }\n    if (Object.entries(this.attributes).find(([key, value]) => other.attributes[key] !== value)) {\n      return false;\n    }\n    return this.children.length === other.children.length;\n  }\n}\n","/**\n * Text node class that manages a text element in the virtual Tree.\n * @export\n * @class TextNode\n */\nexport class TextNode {\n  /**\n   * Class constructor that stores the values.\n   * @param {Object} props - The properties given to this constructor.\n   * @param {String} props.text - Text to display through this virtual node.\n   */\n  constructor({ text }) {\n    /**\n     * Stores the text to display in the DOM when mounted or updated.\n     * @type {String}\n     */\n    this.text = text;\n\n    /**\n     * DOM node assigned to this virtual node for easy access.\n     * @type {Text}\n     */\n    this.domNode = null;\n  }\n\n  /**\n   * Diffing function that returns if the two nodes are the same or not.\n   * @param other {TreeNode|HtmlNode|TextNode}\n   * @returns {boolean} Returns true if the two nodes are the same, false otherwise.\n   */\n  diff(other) {\n    if (!(other instanceof TextNode)) {\n      return false;\n    }\n    return this.text === other.text;\n  }\n}\n","import '../utils/typeDef';\nimport { applyContextToFactory } from '../context/applyContext';\n\n/**\n * Tree node class that manages component based classes. When the node creator hits a function, it will\n * create an instance of this class.\n * @export\n * @class TreeNode\n */\nexport class TreeNode {\n  /**\n   * Class constructor that stores the values.\n   * @param {Object} props - The properties given to this constructor.\n   * @param {functionComponent} props.factory - Component to build when this node is rendered in the view.\n   * @param {object} props.attributes - Attributes to pass to the factory when called.\n   * @param {(TreeNode|HtmlNode|TextNode)[]} props.children - The children to pass to the factory when called.\n   */\n  constructor({ factory, attributes, children }) {\n    /**\n     * Stores the factory used to render this component.\n     * @type {functionComponent}\n     */\n    this.factory = applyContextToFactory(factory);\n\n    /**\n     * The attributes assigned to this node, will be passed to the factory when it is executed.\n     * @type {Object}\n     */\n    this.attributes = attributes;\n\n    /**\n     * Children of the node. Will be passed to the factory when it is execute. Not to confuse with the children\n     * rendered by the factory.\n     * @type {(TreeNode|HtmlNode|TextNode)[]}\n     */\n    this.children = children;\n\n    /**\n     * DOM node assigned to this virtual node for easy access.\n     * @type {HTMLElement}\n     */\n    this.domNode = null;\n  }\n\n  /**\n   * Diffing function that returns if the two nodes are the same or not.\n   * @param other {TreeNode|HtmlNode|TextNode}\n   * @returns {boolean} Returns true if the two nodes are the same, false otherwise.\n   */\n  diff(other) {\n    if (!(other instanceof TreeNode)) {\n      return false;\n    }\n    if (Object.entries(this.attributes).find(([key, value]) => other.attributes[key] !== value)) {\n      return false;\n    }\n    return this.factory === other.factory;\n  }\n}\n","import '../utils/typeDef';\n\n/**\n * Function that augments the received component to add the functionalities to basic function components.\n * Context is added as the second argument on the component factory functions and their values are stored\n * on the component for as long as it is loaded into the DOM.\n * @param {function(): contextObject} contextCreator - function that returns an object containing the context to apply\n * on the component.\n * @param {functionComponent} component - Component on which to add the context.\n * @return {functionComponent} Augmented component with context added.\n */\nexport const applyContext = (contextCreator, component) => {\n  // Temporarily add the context object to the factory so we can build it later.\n  if (!component.contextObjects) {\n    component.contextObjects = [];\n  }\n  component.contextObjects.push(contextCreator);\n\n  // Return the augmented component\n  return component;\n};\n\n/**\n * Function that applies the saved context objects on a component. The context objects\n * need to be saved on the function before getting applied to make sure we clone the data and\n * that no component share their contexts.\n * @param {functionComponent} component - Component on which to add the context.\n * @return {functionComponent} Augmented component with context added.\n */\nexport const applyContextToFactory = component => {\n  if (!component.contextObjects) {\n    return component;\n  }\n\n  // Loop through all of the saved context objects\n  component.contextObjects.forEach(contextBuilder => {\n    if (typeof contextBuilder !== 'function') {\n      throw new Error(\n        `Contexts must be created using a function to prevent components sharing the same context memory. ${\n          typeof contextBuilder} given`\n      );\n    }\n\n    // Build the context object\n    const contextObj = contextBuilder();\n\n    if (!Object.prototype.hasOwnProperty.call(contextObj, 'apply')) {\n      throw new Error(\n        'Context creators must return an object with an `apply` method that takes the previous context as their' +\n        'only argument and return the updated context.'\n      );\n    }\n\n    // Add the context to the function component\n    const previousCreator = component.contextCreator;\n    if (previousCreator) {\n      // If there was a previous context applied to the component, chain them together.\n      component.contextCreator = context => contextObj.apply(previousCreator(context));\n    } else {\n      // Otherwise, create the context creator from the apply function\n      component.contextCreator = contextObj.apply.bind(contextObj);\n    }\n  });\n  delete component.contextObjects;\n\n  // Return the augmented component\n  return component;\n};\n","import { HtmlNode } from '../nodes/htmlNode';\nimport { TextNode } from '../nodes/textNode';\nimport { TreeNode } from '../nodes/treeNode';\n\n/**\n * Function that will apply the given attributes on the HTML element. The old attributes are passed for removing\n * attributes when needed. For example, if an attribute is present in the old attributes, but not in the new\n * attributes, it should be removed from the DOM node.\n * @todo support namespaced attributes\n * @param {Object} oldAttributes - The old attributes that were assigned to the node before the patch.\n * @param {Object} newAttributes - The new attributes that were assigned to the node after the patch.\n * @param {HTMLElement} node - The node on which to apply the attribute changes.\n */\nconst applyAttributes = (oldAttributes = {}, newAttributes = {}, node) => {\n  Object.keys(oldAttributes).forEach(key => {\n    // If the new attributes doesn't have the old attribute\n    if (!Object.prototype.hasOwnProperty.call(newAttributes, key) || !newAttributes[key]) {\n      // Remove the attribute from the node since it is now gone\n      if (typeof node[key] !== 'undefined') {\n        // Delete on the node directly if we can\n        delete node[key];\n      }\n      node.removeAttribute(key);\n    }\n  });\n  // Go over the new attributes\n  Object.entries(newAttributes).forEach(([key, value]) => {\n    if (typeof value !== 'function' && Object.prototype.hasOwnProperty.call(oldAttributes, key) &&\n      oldAttributes[key] === value) {\n      // If the attribute did not change and is not an event listener, don't bother updating\n      return;\n    }\n    if (typeof node[key] !== 'undefined') {\n      // Set on the node directly if we can\n      node[key] = value;\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n      // Set the new attribute value on the node\n      node.setAttribute(key, value);\n    } else if (typeof value === 'boolean') {\n      // For booleans, set the attribute as an empty string if true or remove if false\n      if (value) {\n        node.setAttribute(key, '');\n      } else {\n        node.removeAttribute(key);\n      }\n    }\n  });\n};\n\n/**\n * Generate a DOM node with the given virtual node. If generating a virtual dom component, it will also assign\n * all the properties on the web component.\n * @param {HtmlNode|TextNode|TreeNode} virtualNode - The node from which to create the DOM node.\n * @returns {Node} - Returns a DOM node that can be used directly.\n */\nconst generateNode = virtualNode => {\n  if (virtualNode instanceof HtmlNode) {\n    return document.createElement(virtualNode.tag);\n  } else if (virtualNode instanceof TextNode) {\n    return document.createTextNode(virtualNode.text);\n  } else if (virtualNode instanceof TreeNode) {\n    const rootElement = document.createElement('vdom-component');\n    rootElement.setAll(virtualNode.factory, virtualNode.attributes, virtualNode.children, virtualNode);\n    return rootElement;\n  }\n};\n\n/**\n * Updates a virtual node and its associated DOM node with the values of the new virtual node.\n * @param {HtmlNode|TextNode|TreeNode} oldNode - The node to update.\n * @param {HtmlNode|TextNode|TreeNode} newNode - The node to update from.\n */\nconst updateNode = (oldNode, newNode) => {\n  if (oldNode instanceof HtmlNode) {\n    applyAttributes(oldNode.attributes, newNode.attributes, oldNode.domNode);\n    oldNode.attributes = newNode.attributes;\n  } else if (oldNode instanceof TextNode) {\n    oldNode.text = newNode.text;\n    oldNode.domNode.nodeValue = newNode.text;\n  } else if (oldNode instanceof TreeNode) {\n    // Update the virtual attributes for a component node\n    oldNode.attributes = newNode.attributes;\n    oldNode.children = newNode.children;\n    oldNode.factory = newNode.factory;\n    // Update the DOM attributes from the associated web component\n    oldNode.domNode.setAll(newNode.factory, newNode.attributes, newNode.children, oldNode);\n  }\n};\n\n/**\n * Main diffing algorithm that will diff nodes and patch them in place, generating DOM mutations alongside virtual DOM\n * mutations. Will be recursively called on all the nodes in the tree until the entire tree has been patched.\n * @todo Improve performance\n * @param {HtmlNode|TextNode|TreeNode} parent - The parent of the old and new node. Used to add or remove children.\n * @param {HtmlNode|TextNode|TreeNode} oldNode - The node from the tree that is being patched. Is modified by the\n * algorithm.\n * @param {HtmlNode|TextNode|TreeNode} newNode - The node from the new tree used to patch the old tree.\n * @export\n */\nexport const patch = (parent, oldNode, newNode) => {\n  if (!newNode) {\n    // If a null or undefined should get here, ignore it.\n    return;\n  }\n\n  // If Old node does not exists, then we are mounting for the first time\n  if (!oldNode) {\n    // Generate the dom node\n    const domNode = generateNode(newNode);\n    newNode.domNode = domNode;\n    if (newNode instanceof HtmlNode) {\n      applyAttributes({}, newNode.attributes, domNode);\n    }\n\n    // Start patching on the new node's children\n    if (newNode.children) {\n      newNode.children.forEach(child => patch(newNode, null, child));\n    }\n    parent.domNode.appendChild(domNode);\n    return;\n  }\n\n  // If the two nodes don't have the same type\n  if (oldNode.prototype !== newNode.prototype) {\n    // Replace the old child with the new child\n    parent.children = parent.children.map(child => {\n      if (child === oldNode) {\n        return newNode;\n      }\n      return child;\n    });\n    const domNode = generateNode(newNode);\n    newNode.domNode = domNode;\n    if (newNode instanceof HtmlNode) {\n      applyAttributes(oldNode.attributes, newNode.attributes, domNode);\n    }\n    if (!(newNode instanceof TreeNode)) {\n      // Start patching the new node if they are not components\n      // If they are components, the connectedCallback function will take care of the rest\n      patch(parent, null, newNode);\n    }\n    parent.domNode.replaceChild(domNode, oldNode.domNode);\n  }\n\n  // If the nodes are different, but of the same type\n  if (!oldNode.diff(newNode)) {\n    // Update the nodes\n    updateNode(oldNode, newNode);\n    if (oldNode instanceof TreeNode) {\n      // If this node is a component, stop right here and update the component.\n      // The component will take care of patching the children\n      oldNode.domNode.update();\n      return;\n    }\n  }\n\n  // Proceed to update the children or replace them if needed\n  const oldChildrenQueue = [...(oldNode && oldNode.children ? oldNode.children : [])].reverse();\n  const newChildrenQueue = [...(newNode && newNode.children ? newNode.children : [])].reverse();\n  let index = 0;\n  // Loop in the old children until we have no more children\n  while (oldChildrenQueue.length) {\n    const oldChild = oldChildrenQueue.pop();\n    // If there are no more new children\n    if (!newChildrenQueue.length) {\n      // We have to remove the remaining old children and break the loop\n      oldNode.children.slice(index).forEach(child => {\n        oldNode.domNode.removeChild(child.domNode);\n      });\n      oldNode.children = oldNode.children.slice(0, index);\n      break;\n    }\n\n    index++;\n    const newChild = newChildrenQueue.pop();\n\n    // Start patching the two nodes\n    patch(oldNode, oldChild, newChild);\n  }\n\n  // Loop in the new children if there are more\n  while (newChildrenQueue.length) {\n    const newChild = newChildrenQueue.pop();\n    oldNode.children.push(newChild);\n\n    // Generate the new node and append it to the dom\n    const domNode = generateNode(newChild);\n    newChild.domNode = domNode;\n    if (newChild instanceof HtmlNode) {\n      applyAttributes({}, newChild.attributes, domNode);\n    }\n\n    // Start patching the new node's children\n    if (newChild.children) {\n      newChild.children.forEach(child => patch(newChild, null, child));\n    }\n    oldNode.domNode.appendChild(domNode);\n  }\n};\n","import { patch } from '../diffing/patchTree';\nimport '../utils/typeDef';\n\n/**\n * Custom element that allows us to manage components as trees rather than nodes of a tree. These components\n * are stored inside of the actual DOM and keep their own virtual tree. When one is added to the DOM structure,\n * it will render the function stored in factory and mount the virtual nodes into the DOM.\n * @export\n * @class ComponentElement\n * @extends window.HTMLElement\n */\nclass ComponentElement extends window.HTMLElement {\n  /**\n   * Class constructor.\n   */\n  constructor() {\n    super();\n\n    /**\n     * Stores whether or not the component has mounted the content of its factory. Will not update\n     * if it has yet to be mounted.\n     * @type {boolean}\n     */\n    this.mounted = false;\n\n    /**\n     * Stores the properties of the component given as attributes when the `createNode` function is called.\n     * @type {{}}\n     */\n    this.props = {};\n\n    /**\n     * Stores the virtual children that are to be passed to the factory when rendering.\n     * @type {TreeNode|TextNode|HtmlNode}\n     */\n    this.virtualChild = null;\n\n    /**\n     * The factory to execute when this component mounts or update.\n     * @type {functionComponent}\n     */\n    this.factory = () => null;\n\n    /**\n     * The context is a special function that takes in a context object and will return a context object. By executing\n     * the given function, it will run the `apply` function on each of the context objects applied on the component and\n     * return the updated context to augment the component with.\n     * @type {function(Object): Object}\n     */\n    this.contextCreator = context => context;\n\n    /**\n     * Object that stores the component's context data. Updated with state management capabilities for the framework.\n     * @type {{}}\n     */\n    this.context = {\n      setState: (key, value) => {\n        this.context[key] = value;\n        this.requestUpdate();\n      },\n    };\n\n    /**\n     * Object containing lifecycle listener functions.\n     * @typedef lifecycleListeners\n     * @property {function(ComponentElement)} beforeMount - Hook called after the component has been connected to\n     * the DOM and before it is mounted.\n     * @property {function(ComponentElement)} afterMount - Hook called after the component has been successfully\n     * mounted.\n     * @property {function(ComponentElement)} beforeUpdate - Hook called before the component is updated and before\n     * checking if we should update.\n     * @property {function(ComponentElement): boolean} shouldUpdate - Hook called before the component is updated.\n     * Return false to prevent updating the component. Does not provide the old or new attributes, the developer\n     * is in charge of keep track of those.\n     * @property {function(ComponentElement)} afterUpdate - Hook called after an update has been processed.\n     * @property {function(ComponentElement)} beforeDisconnect - Hook called before the component is disconnected\n     * from the DOM.\n     */\n\n    /**\n     * Object containing functions that listen to the various lifecycle events of a component. These functions\n     * will be executed with the current component as their only parameter.\n     * @type {lifecycleListeners}\n     */\n    this.lifecycleListeners = {\n      afterConnect: () => {},\n      beforeMount: () => {},\n      afterMount: () => {},\n      beforeUpdate: () => {},\n      shouldUpdate: () => true,\n      afterUpdate: () => {},\n      beforeDisconnect: () => {},\n    };\n\n    /**\n     * The tree mounted on this component. When the component updates, this tree is updated in place.\n     * @type {TreeNode|TextNode|HtmlNode}\n     */\n    this.tree = null;\n\n    /**\n     * The TreeNode instance for this component to make sure the two can properly communicate.\n     * @type {TreeNode}\n     */\n    this.node = null;\n  }\n\n  /**\n   * Update the values of the DOM component from the values passed in parameter.\n   * @param {functionComponent} factory - Function to render the component.\n   * @param {{}} props - Properties to give to the factory.\n   * @param {TreeNode|TextNode|HtmlNode} virtualChild - Child to give to the factory.\n   * @param {TreeNode} node - Underlying virtual node backing the DOM node.\n   */\n  setAll(factory, props, virtualChild, node) {\n    this.factory = factory;\n    this.contextCreator = this.factory.contextCreator || (context => context);\n    this.props = props;\n    this.virtualChild = virtualChild;\n    this.node = node;\n\n    this.applyContext();\n  }\n\n  /**\n   * The lifecycle method called by the DOM. Will use the fact that the node has been added to the DOM to\n   * mount the content of the factory.\n   */\n  connectedCallback() {\n    this.mount();\n  }\n\n  /**\n   * The lifecycle method called by the DOM with the component is disconnected from it.\n   */\n  disconnectedCallback() {\n    this.lifecycleListeners.beforeDisconnect.call(this, this.context);\n    this.mounted = false;\n  }\n\n  /**\n   * Method that executes the context creator on this nodeand saves the updated context.\n   */\n  applyContext() {\n    // Generate the context from the previous context\n    const finalContext = this.contextCreator({\n      ...this.context,\n      requestUpdate: this.requestUpdate.bind(this),\n    });\n\n    // Loop on each of the available lifecycle hooks\n    [\n      'afterConnect',\n      'beforeMount',\n      'afterMount',\n      'beforeUpdate',\n      'shouldUpdate',\n      'afterUpdate',\n      'beforeDisconnect'\n    ].forEach(hook => {\n      // If the context object has a hook defined and it is a function\n      if (finalContext[hook] && typeof finalContext[hook] === 'function') {\n        // Add that lifecycle hook to the component properties\n        this.listen(hook, finalContext[hook]);\n        delete finalContext[hook];\n      }\n    });\n\n    // Update the element context with the new context.\n    this.context = finalContext;\n  }\n\n  /**\n   * Function that sets a specific lifecycle hook listener. Will do nothing if the lifecycle hook\n   * is unknown.\n   * @see lifecycleListeners\n   * @param {String} hook - Hook to listen to.\n   * @param {function} listener - Listener function to set for the given hook.\n   */\n  listen(hook, listener) {\n    if (Object.prototype.hasOwnProperty.call(this.lifecycleListeners, hook)) {\n      this.lifecycleListeners[hook] = listener;\n    }\n  }\n\n  /**\n   * Mount method that is triggered when the component is mounted to the DOM. Will render the tree for the first time\n   * and diff it against the empty DOM.\n   */\n  mount() {\n    this.tree = this.render();\n    this.lifecycleListeners.beforeMount.call(this, this.context);\n    patch(this.node, null, this.tree);\n    this.mounted = true;\n    this.lifecycleListeners.afterMount.call(this, this.context);\n  }\n\n  /**\n   * Requests and update on the component that will trigger and update if the component is still mounted.\n   * @todo Add ability to batch updates\n   */\n  requestUpdate() {\n    if (this.mounted) {\n      this.applyContext();\n      this.update();\n    }\n  }\n\n  /**\n   * Update method that will trigger a new render of this virtual tree and execute the diffing algorithm.\n   */\n  update() {\n    this.lifecycleListeners.beforeUpdate.call(this, this.context);\n    if (!this.lifecycleListeners.shouldUpdate.call(this, this.context)) {\n      return;\n    }\n    const vtree = this.render();\n    patch(this.node, this.tree, vtree);\n    this.lifecycleListeners.afterUpdate.call(this, this.context);\n  }\n\n  /**\n   * Render method used to render the factory using the component's state and properties.\n   * @private\n   * @returns {TreeNode|TextNode|HtmlNode} Returns the rendered factory.\n   */\n  render() {\n    return this.factory({\n      ...this.props,\n      children: this.virtualChild,\n    }, this.context);\n  }\n}\n\nwindow.customElements.define('vdom-component', ComponentElement);\n","/**\n * Utility method that will flatten an array with infinite depth down to a single continuous array.\n * This method will remove any null or empty elements without modifying the original array.\n * @param input {Array} - The input array to flatten.\n * @returns {*[]} The flattened array without any nulls or undefined.\n */\nexport const flatten = input => {\n  // Create a stack with all the inputs\n  const stack = [...input];\n  const res = [];\n  // While there are elements in the stack\n  while (stack.length) {\n    // Pop value from stack\n    const next = stack.pop();\n    if (Array.isArray(next)) {\n      // Push back array items without modifying the original input\n      stack.push(...next);\n    } else if (next !== null && typeof next !== 'undefined') {\n      // If the next element is not an array, make sure it is not null or undefined.\n      res.push(next);\n    }\n  }\n\n  // Reverse to restore input order, adding at the end of an array is far more performant than adding at the beginning.\n  return res.reverse();\n};\n","import { TreeNode } from './treeNode';\nimport { TextNode } from './textNode';\nimport { HtmlNode } from './htmlNode';\nimport { flatten } from '../utils/flattenArray';\n\n/**\n * Transform all children that are not object readable bu the `createNode` function into an object\n * that can ve processed by that same function. In particular, it makes sure that you can pass a string as\n * a children and still get a valid node.\n *\n * This enables something like:\n * @example\n *   createNode(\"span\", {}, \"Hello, world!\");\n * @param child {*} - The children the manage. This function is intended to be called within a `.map` call.\n * @returns {TreeNode|TextNode|HtmlNode|*} Returns a valid virtual node.\n */\nconst vdonizeChildren = child =>\n  typeof child === 'string' || typeof child === 'number' || typeof child === 'boolean'\n    ? createNode({ text: child }, {}) : child;\n\n/**\n * This factory method takes JSX compliant parameters and generate small objects that represent our\n * virtual nodes. By walking this tree of nodes, we can process the virtual DOM tree and mount in on the DOM.\n *\n * If given a string as the tag, it will render an HTML node. Text nodes are managed through the `vdonizeChildren`\n * method, meaning that your only way to create text nodes is by giving a text children to another node. It also means\n * that the root node of an application cannot be a text node.\n *\n * If given a function as the tag, the creator will return a TreeNode to generate a new subtree and\n * execute the component.\n *\n * @example\n * createNode(({ text }) => createNode(\"h1\", { style: \"color: red;\" }, text), { text: \"Hello, World!\" });\n * @param tag {String|Function|{ text: String }} - The tag of this virtual node.\n * @param attributes {Object} - The attributes of the node if it needs any. Only components and HTML nodes use\n * attributes.\n * @param children {TreeNode|TextNode|HtmlNode|String} - the children to pass to the virtual node if it needs any.\n * Text nodes will ignore the children parameter if they are given some.\n * @returns {TreeNode|TextNode|HtmlNode} Returns a valid virtual node.\n * @export\n */\nexport const createNode = (tag, attributes = {}, ...children) => {\n  // protect against null attributes\n  let props = attributes || {};\n\n  // Remove attributes added by JSX in development\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-unused-vars\n    const { __self, __source, ...rest } = props;\n    props = rest;\n  }\n\n  // Flatten the children so that any array created with things like .map are processed as a single continuous array.\n  // TODO: This might be inefficient long term.\n  const flatChildren = flatten(children);\n  if (typeof tag === 'function') {\n    // Clone the tag so components do not share context\n    const cloned = tag.bind({});\n    Object.assign(cloned, tag);\n\n    return new TreeNode({\n      factory: cloned,\n      attributes: props,\n      children: flatChildren.map(vdonizeChildren),\n    });\n  }\n  if (Object.prototype.hasOwnProperty.call(tag, 'text')) {\n    return new TextNode({ text: tag.text });\n  }\n\n  return new HtmlNode({\n    tag,\n    attributes: props,\n    children: flatChildren.map(vdonizeChildren),\n  });\n};\n","/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","/** @jsx h */\nimport { h } from '../../vdom';\nimport classNames from 'classnames';\n\nconst ALL_TODOS = 'all';\nconst ACTIVE_TODOS = 'active';\nconst COMPLETED_TODOS = 'completed';\n\nexport const Footer = ({ count, completedCount, nowShowing, setNowShowing, clearCompleted }) => {\n  const activeTodoWord = count > 1 ? 'items' : 'item';\n\n  let clearButton = null;\n  if (completedCount > 0) {\n    clearButton = (\n      <button\n        class=\"clear-completed\"\n        onclick={clearCompleted}>\n        Clear completed\n      </button>\n    );\n  }\n\n  return (\n    <footer class=\"footer\">\n      <span class=\"todo-count\">\n        <strong>{count}</strong> {activeTodoWord} left\n      </span>\n      <ul class=\"filters\">\n        <li>\n          <a\n            onclick={() => setNowShowing(ALL_TODOS)}\n            class={classNames({ selected: nowShowing === ALL_TODOS })}>\n            All\n          </a>\n        </li>\n        {' '}\n        <li>\n          <a\n            onclick={() => setNowShowing(ACTIVE_TODOS)}\n            class={classNames({ selected: nowShowing === ACTIVE_TODOS })}>\n            Active\n          </a>\n        </li>\n        {' '}\n        <li>\n          <a\n            onclick={() => setNowShowing(COMPLETED_TODOS)}\n            class={classNames({ selected: nowShowing === COMPLETED_TODOS })}>\n            Completed\n          </a>\n        </li>\n      </ul>\n      {clearButton}\n    </footer>\n  );\n};\n",null,"/** @jsx h */\nimport { h } from '../../vdom';\nimport classNames from 'classnames';\n\nexport const TodoItem = ({ todo, model }, { isEditing = false, editTodo = todo.title, setState }) => {\n  const setIsEditing = val => setState('isEditing', val);\n  const setEditTodo = val => setState('editTodo', val);\n\n  const handleSubmit = () => {\n    const val = editTodo.trim();\n\n    if (val) {\n      model.editTodo(todo.id, val);\n      setIsEditing(false);\n    }\n  };\n\n  const handleChange = event => {\n    setEditTodo(event.target.value);\n  };\n\n  const handleStartEditing = () => {\n    setEditTodo(todo.title);\n    setIsEditing(true);\n  };\n\n  const handleKeyDown = event => {\n    if (event.key !== 'Enter') {\n      return;\n    }\n\n    event.preventDefault();\n    handleSubmit();\n  };\n\n  return (\n    <li class={classNames({\n      completed: todo.completed,\n      editing: isEditing\n    })}>\n      <div class=\"view\">\n        <input\n          class=\"toggle\"\n          type=\"checkbox\"\n          checked={todo.completed}\n          onchange={() => model.toggle(todo.id)}\n        />\n        <label ondblclick={handleStartEditing}>\n          {todo.title}\n        </label>\n        <button class=\"destroy\" onclick={() => model.removeTodo(todo.id)} />\n      </div>\n      <input\n        class=\"edit\"\n        value={editTodo}\n        onblur={handleSubmit}\n        oninput={handleChange}\n        onkeydown={handleKeyDown}\n      />\n    </li>\n  );\n};\n","let currentId = 0;\n\nexport default (todos, setTodos) => {\n  return {\n    addTodo(title) {\n      currentId++;\n\n      setTodos([].concat(todos, { id: currentId, title, completed: false }));\n    },\n\n    editTodo(id, newTitle) {\n      setTodos(todos.map(todo => todo.id === id ? { ...todo, title: newTitle } : todo));\n    },\n\n    removeTodo(id) {\n      setTodos(todos.filter(todo => todo.id !== id));\n    },\n\n    all() {\n      return [...todos];\n    },\n\n    toggleAll(checked = true) {\n      setTodos(todos.map(todo => ({ ...todo, completed: checked })));\n    },\n\n    toggle(id) {\n      setTodos(todos.map(todo => todo.id === id ? { ...todo, completed: !todo.completed } : todo));\n    },\n  };\n};\n","/** @jsx h */\nimport { VirtualDOM } from '../vdom';\n\nimport { App } from './components/app';\n\n/* const App = ({ time = new Date() }, { setState }) => {\n  window.setTimeout(() => setState('time', new Date()), 1000);\n\n  return (\n    <div>\n      <h1>The current time is:</h1>\n      {time.toLocaleTimeString('en-US')}\n    </div>\n  );\n  // const timeString = time.toLocaleTimeString('en-US');\n  // return h('div', {}, h('h1', {}, 'The current time is: '), h('span', {}, timeString));\n}; */\n\nnew VirtualDOM(App).renderInto(document.querySelector('.todoapp'));\n","import './tree/component';\nimport { createNode } from './nodes/factory';\nimport { TreeNode } from './nodes/treeNode';\nimport { applyContext } from './context/applyContext';\n\n/**\n * Constructor that enables the creation of a virtual DOM tree for the given component. This constructor can be called\n * multiple times on different components, there is no limit to the amount of virtual trees in a single page.\n *\n * @example\n * new VirtualDOM(App).renderInto(\"#app\");\n * @example\n * // You can also cache the tree for rendering in multiple locations\n * const app = new VirtualDOM(App);\n * app.renderInto(\"#app\");\n * app.renderInto(\"#other-app\");\n * @param root {TreeNode} - The component to render as the root of this tree.\n * @returns {{renderInto: renderInto}} Returns an object that can be chained to render this application into\n * multiple nodes.\n * @constructor\n * @export\n */\nexport function VirtualDOM(root) {\n  return {\n    /**\n     * Function that will render this application in the given HTMLElement.\n     * @param element {HTMLElement} - The element to use as the root of the application.\n     */\n    renderInto: element => {\n      if (typeof root !== 'function') {\n        throw new Error('The root of a virtual DOM tree must be a component');\n      }\n      const rootElement = document.createElement('vdom-component');\n      const virtualNode = new TreeNode({ factory: root, children: [], attributes: {} });\n      virtualNode.domNode = rootElement;\n      rootElement.setAll(root, {}, null, virtualNode);\n      element.appendChild(rootElement);\n    },\n  };\n}\n\nexport { createNode as h, applyContext };\n","/** @jsx h */\nimport { h } from '../../vdom';\n\nimport { Footer } from './footer';\nimport { TodoItem } from './todoItem';\nimport useTodoModel from '../model/todoModel';\n\nconst ALL_TODOS = 'all';\nconst ACTIVE_TODOS = 'active';\nconst COMPLETED_TODOS = 'completed';\n\nexport const App = (_, { todos = [], newTodo = '', nowShowing = ALL_TODOS, setState }) => {\n  const setNowShowing = val => setState('nowShowing', val);\n  const setNewTodo = val => setState('newTodo', val);\n  const setTodos = val => setState('todos', val);\n  const model = useTodoModel(todos, setTodos);\n\n  const handleChange = event => {\n    setNewTodo(event.target.value);\n  };\n\n  const handleNewTodoKeyDown = event => {\n    if (event.key !== 'Enter') {\n      return;\n    }\n\n    event.preventDefault();\n\n    const val = newTodo.trim();\n\n    if (val) {\n      model.addTodo(val);\n      setNewTodo('');\n    }\n  };\n\n  const allTodos = model.all();\n  const shownTodos = allTodos.filter(todo => {\n    switch (nowShowing) {\n      case ACTIVE_TODOS:\n        return !todo.completed;\n      case COMPLETED_TODOS:\n        return todo.completed;\n      default:\n        return true;\n    }\n  });\n\n  const activeTodoCount = allTodos.reduce((accum, todo) => todo.completed ? accum : accum + 1, 0);\n\n  const completedCount = allTodos.length - activeTodoCount;\n\n  return (\n    <div>\n      <header class=\"header\">\n        <h1>todos</h1>\n        <input\n          class=\"new-todo\"\n          placeholder=\"What needs to be done?\"\n          value={newTodo}\n          onkeydown={handleNewTodoKeyDown}\n          oninput={handleChange}\n          autoFocus={true}\n        />\n      </header>\n      {todos.length ? (\n        <section class=\"main\">\n          <input\n            id=\"toggle-all\"\n            class=\"toggle-all\"\n            type=\"checkbox\"\n            onchange={() => model.toggleAll(activeTodoCount !== 0)}\n            checked={activeTodoCount === 0}\n          />\n          <label\n            htmlFor=\"toggle-all\"\n          />\n          <ul class=\"todo-list\">\n            {shownTodos.map(todo => <TodoItem key={todo.id} todo={todo} model={model} />)}\n          </ul>\n        </section>\n      ) : null}\n      {(activeTodoCount || completedCount) ? (\n        <Footer\n          count={activeTodoCount}\n          completedCount={completedCount}\n          nowShowing={nowShowing}\n          setNowShowing={setNowShowing}\n          clearCompleted={() => model.toggleAll(false)}\n        />\n      ) : null}\n    </div>\n  );\n};\n"]}