(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{68:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return p}));var o=n(2),a=n(6),r=(n(0),n(73)),i={title:"Context: Introduction"},c={unversionedId:"context/overview",id:"context/overview",isDocsHomePage:!1,title:"Context: Introduction",description:"The context is an object stored in the component custom element. This object is passed on every execution of a",source:"@site/docs/context/overview.md",permalink:"/carleton-web-dev/project/docs/context/overview",sidebar:"docs",previous:{title:"Creating applications",permalink:"/carleton-web-dev/project/docs/introduction/applications"},next:{title:"Context: Callbacks",permalink:"/carleton-web-dev/project/docs/context/callbacks"}},l=[{value:"Getting started with context",id:"getting-started-with-context",children:[]},{value:"Lifecycle hooks",id:"lifecycle-hooks",children:[]}],s={rightToc:l};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(o.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"The context is an object stored in the component custom element. This object is passed on every execution of a\ncomponent's function and - contrary to properties which are cloned on every execution - can be safely mutated\n. Mutating the context is the main way the framework provides state management capabilities. However, it allows\nenables developers to hook into the component lifecycle methods and to provide more APIs through the use of this\nmutable memory. This makes components indefinitely expandable and can provide any functionality you can think of,\n",Object(r.b)("em",{parentName:"p"},"in theory at least"),"."),Object(r.b)("h2",{id:"getting-started-with-context"},"Getting started with context"),Object(r.b)("p",null,"Context, in is simplest of forms, is an object with an ",Object(r.b)("inlineCode",{parentName:"p"},"apply")," function that will be executed in every render cycle\n. If applied to components using the helper function ",Object(r.b)("inlineCode",{parentName:"p"},"applyContext"),", they can be chained together to give virtually\nan infinite number of context objects to a component."),Object(r.b)("p",null,"For example, imagine that we want to provide some API data to a component:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-jsx"}),"const ComponentWithAPIData = (_, { data, setState }) => {\n  if (!data) {\n    fetch('some/api/url').then(data => data.json()).then(data => setState('data', data));\n  }\n\n  // Do something with that data\n}; \n")),Object(r.b)("p",null,"If we want to reuse this logic in multiple components, we end up rewriting a lot of code. This type of behavior is\nalso very difficult to test in isolation. There's also the fact that we have no way to make sure the fetch\nfunction will only be called once, which may lead to infinite loops or refetching. This is less of an issue with\nVirtualDOM since all components update in isolation, bu tit is still something we want to prevent if possible. Let's\nrewrite this by using context instead."),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-javascript"}),"import { applyContext } from 'VirtualDOM';\n\nconst withAPI = (component) => {\n  return applyContext(() => ({\n    fetchData(setState) {\n      fetch('some/api/url').then(data => data.json()).then(data => {\n        setState('data', data);\n      });\n    }, \n\n    apply({ setState, ...rest }) {\n      // Always return the rest of the context plus anything you extracted from it.\n      return {\n        ...rest,\n        setState, // Do not forget to return the setState method as well!\n        afterMount: () => {\n          this.fetchData(setState);\n        },\n      };\n    }\n  }), component);\n};\n\nconst ComponentWithAPIData = withAPI((_, { data }) => {\n  // Do something with that data\n});\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"withAPI")," is our context function. It should return a call to the ",Object(r.b)("inlineCode",{parentName:"p"},"applyContext")," helper with two parameters, a context\ncreator and the component to augment with context. The context creator is a function that should return the context\nobject, it is called everytime a component is created using the ",Object(r.b)("inlineCode",{parentName:"p"},"h")," function. This makes sure all instances of\na component have their own copy of the context object, rather than all share the same one."),Object(r.b)("p",null,"The context object is where we will work our magic to anything we want to the context of an object. This object is\nstored in memory for as long as the component exists. Anything we save in there is unique to that component and will\nfollow it through updates. If the component is ever unmounted (If it is removed from the tree for example), its\ncontext is deleted as well. Even better, we still have access to state management for the component inside of its\ncontext object, meaning we can use the component state to save data rather than the context memory. The built-in\nstate options should cover most use cases, but we'll see in a later guide how context memory can also be used to\nprovide more complex APIs."),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"apply")," function will be, as explained before, called everytime the function component is executed. It receives\nthe previous context and must return an updated context. The first apply function called will receive the context\nobject with the component's state, the ",Object(r.b)("inlineCode",{parentName:"p"},"setState")," method and a ",Object(r.b)("inlineCode",{parentName:"p"},"requestUpdate")," function. This function allows the\ncaller to trigger an update on the component without setting any state, which is particulary useful when storing\ndata in context memory rather than the state."),Object(r.b)("p",null,"These functions are called in order of applications. Let's explain that with an example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-javascript"}),"const augmentedComponent = withContext1(withContext2(component));\n")),Object(r.b)("p",null,"Here, ",Object(r.b)("inlineCode",{parentName:"p"},"withContext2"),"'s ",Object(r.b)("inlineCode",{parentName:"p"},"apply")," function will be called first, then ",Object(r.b)("inlineCode",{parentName:"p"},"withContext1"),"'s ",Object(r.b)("inlineCode",{parentName:"p"},"apply")," function second. If\n",Object(r.b)("inlineCode",{parentName:"p"},"withContext2")," adds anything to the context, ",Object(r.b)("inlineCode",{parentName:"p"},"withContext1")," can overwrite it if we are not careful. This is why you\nshould always return the complete context with your added changes from an ",Object(r.b)("inlineCode",{parentName:"p"},"apply")," function."),Object(r.b)("h2",{id:"lifecycle-hooks"},"Lifecycle hooks"),Object(r.b)("p",null,"Context objects can do a lot more than just add more state to a component. They can also hook into lifecycle methods\n. In the previous example, we triggered our API fetch from a property on the context called ",Object(r.b)("inlineCode",{parentName:"p"},"afterMount"),". This is a\nlifecycle hook. By returning an object with any of the lifecycle hooks set, the component will call these functions\nat specific moment in its lifecycle. In this case, we trigger the fetch only after the component has rendered once\nand been mounted on the DOM, and we can be sure this function will never execute again while the component exists."),Object(r.b)("p",null,"All lifecycle hooks have the current component context as their only attribute and their ",Object(r.b)("inlineCode",{parentName:"p"},"this")," property will be\nbound to the custom element instance. Let's list all the lifecycle methods that are available from the context object:"),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object(o.a)({parentName:"tr"},{align:null}),Object(r.b)("strong",{parentName:"th"},"Hook")),Object(r.b)("th",Object(o.a)({parentName:"tr"},{align:null}),Object(r.b)("strong",{parentName:"th"},"Parameters")),Object(r.b)("th",Object(o.a)({parentName:"tr"},{align:null}),Object(r.b)("strong",{parentName:"th"},"Description")))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"afterConnect")),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Context on the component"),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Triggered after the component has been connected to a DOM element, but before it is mounted. The virtual tree has not been rendered yet and this executes before the function component is executed. The component might not exist in the DOM yet.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"beforeMount")),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Context on the component"),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Triggered before VirtualDOM mounts this component's tree to the DOM, but after the component function has been executed.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"afterMount")),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Context on the component"),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Triggered after VirtualDOM has mounted to the DOM.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"beforeUpdate")),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Context on the component"),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Triggered before the component is set to update. The component function has yet to be re-executed at this point.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"shouldUpdate")),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Context on the component"),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Triggered every time an update is requested. If this hooks return true, the update cycle will stop for this component.")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"afterUpdate")),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Context on the component"),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Triggered after the component has been updated, if it was not prevented by ",Object(r.b)("inlineCode",{parentName:"td"},"shouldUpdate"),".")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"beforeDisconnect")),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Context on the component"),Object(r.b)("td",Object(o.a)({parentName:"tr"},{align:null}),"Triggered before the component will disconnect from the DOM. The component might not be available in the DOM at this point, but has yet to be cleaned.")))),Object(r.b)("p",null,"A developer can only set a hook on the context object once. If chaining contexts together, only the last assignation\nwill be processed. Consider a case like this for example:"),Object(r.b)("pre",null,Object(r.b)("code",Object(o.a)({parentName:"pre"},{className:"language-javascript"}),"const withContext1 = (component) => {\n  return applyContext(() => ({\n    apply(context) {\n      return {\n        ...context,\n        afterMount: () => { /* Do something */ },\n      };\n    }\n  }), component);\n};\n\nconst withContext2 = (component) => {\n  return applyContext(() => ({\n    apply(context) {\n      return {\n        ...context,\n        afterMount: () => { /* Do something else */ },\n      };\n    }\n  }), component);\n};\n\nconst AugmentedComponent = withContext1(withContext2(Component));\n")),Object(r.b)("p",null,"In this specific case, only the ",Object(r.b)("inlineCode",{parentName:"p"},"afterMount")," function from ",Object(r.b)("inlineCode",{parentName:"p"},"withContext1")," will be executed since it is added last\n. The developer is responsible from changing this default behavior if they want to allow calling multiple lifecycle\nhooks for a single component. See the ",Object(r.b)("a",Object(o.a)({parentName:"p"},{href:"/recipes/multiple-hooks"}),"Multiple hooks for a single component recipe")," for\nmore details."),Object(r.b)("p",null,"In the next sections on context, we will explore some context specific recipes and see how the API can be used to\nexpand VirtualDOM's API."))}p.isMDXComponent=!0},73:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var o=n(0),a=n.n(o);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=a.a.createContext({}),p=function(e){var t=a.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},b=function(e){var t=p(e.components);return a.a.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},d=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,i=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),b=p(n),d=o,m=b["".concat(i,".").concat(d)]||b[d]||h[d]||r;return n?a.a.createElement(m,c(c({ref:t},s),{},{components:n})):a.a.createElement(m,c({ref:t},s))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var s=2;s<r;s++)i[s]=n[s];return a.a.createElement.apply(null,i)}return a.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);