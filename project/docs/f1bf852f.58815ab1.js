(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{71:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return s})),a.d(t,"rightToc",(function(){return l})),a.d(t,"default",(function(){return c}));var r=a(2),n=a(6),o=(a(0),a(75)),i={title:"Benchmarks: Performance report"},s={unversionedId:"benchmarks/benchmark-report",id:"benchmarks/benchmark-report",isDocsHomePage:!1,title:"Benchmarks: Performance report",description:"This reports explains the results of the benchmarks found here//minivera.github.io/carleton-web-dev/project",source:"@site/docs/benchmarks/benchmark-report.md",permalink:"/carleton-web-dev/project/docs/benchmarks/benchmark-report",sidebar:"docs",previous:{title:"Benchmarks: Overview",permalink:"/carleton-web-dev/project/docs/benchmarks/overview"},next:{title:"Recipes: Index",permalink:"/carleton-web-dev/project/docs/recipes/recipe-index"}},l=[{value:"Algorithms",id:"algorithms",children:[{value:"Recursive algorithm",id:"recursive-algorithm",children:[]},{value:"Iterative algorithm",id:"iterative-algorithm",children:[]},{value:"Separated diff and patch steps",id:"separated-diff-and-patch-steps",children:[]}]},{value:"Report",id:"report",children:[{value:"Recursive",id:"recursive",children:[]},{value:"Iterative",id:"iterative",children:[]},{value:"Separated diff and patch steps",id:"separated-diff-and-patch-steps-1",children:[]}]},{value:"Future of the algorithms",id:"future-of-the-algorithms",children:[]}],h={rightToc:l};function c(e){var t=e.components,a=Object(n.a)(e,["components"]);return Object(o.b)("wrapper",Object(r.a)({},h,a,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"This reports explains the results of the benchmarks found here: ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://minivera.github.io/carleton-web-dev/project"}),"https://minivera.github.io/carleton-web-dev/project"),"\n/benchmark-data/table.html. Before we dive into the results, let's explain the three algorithms used for VirtualDOM."),Object(o.b)("h2",{id:"algorithms"},"Algorithms"),Object(o.b)("h3",{id:"recursive-algorithm"},"Recursive algorithm"),Object(o.b)("p",null,"The recursive algorithm uses a simple ",Object(o.b)("inlineCode",{parentName:"p"},"patch")," function that is executed on the next animation frame when a component\nrequests an update. This patch function will look at the old virtual DOM tree and compare it with the newly\ngenerated virtual DOM tree after the component executed the component function with the updated context. By walking\nthe two trees at the same time, we compare both the old tree node and the new tree node and update the nodes in-place\nwhen we detect changes. We also run the DOM itself at the same time while walking the tree. We keep walking\nthe tree recursively by calling the ",Object(o.b)("inlineCode",{parentName:"p"},"patch")," function on a node's children, if it has any."),Object(o.b)("h3",{id:"iterative-algorithm"},"Iterative algorithm"),Object(o.b)("p",null,'Recursion in JavaScript can be notoriously problematic with recursion, as each browser have their own "stack limit\n". This means that each browser will, at some point, limit the amount of function you can execute until you return.\nIn the case of the virtual DOM, it is unlikely a developer will create a 200000 nodes deep virtual tree. However,\nthe memory weight of all those call stacks can still be a problem for slower devices, and I wanted to see if an\niterative algorithm could be lighter and quicker than a recursive algorithm'),Object(o.b)("p",null,"The iterative algorithm works in the same way as the recursive algorithm, but it uses a massive array to stack all\nthe nodes to visit for both trees, with one stack for each trees. One difference between the two algorithms is the\niterative algorithm will process all of a node's children before moving deeper in the tree."),Object(o.b)("h3",{id:"separated-diff-and-patch-steps"},"Separated diff and patch steps"),Object(o.b)("p",null,"The two previous algorithms modify the virtual and DOM tree in-place while the algorithm runs. This can have the\nunintended side effect of slowing down the multiple loops needed for walking the tree for complex operations,\nslowing down the tree walk operation. Rather than slow down the tree walking, potentially causing issues in\nmultiple loops at the same time, this algorithm records the needed changes in small objects called ",Object(o.b)("inlineCode",{parentName:"p"},"patches")," and\nreturns all the patches generated once it has finished executing."),Object(o.b)("p",null,"We use a new loop to loop over all those patches and execute them one by one. With this method, we can be sure\nthe complex DOM and virtual DOM operations will only execute in one loop. There are some optimizations we can add to\nthis algorithm that are impossible to add to the other algorithms thanks to this separation, like asynchronous\noperations."),Object(o.b)("h2",{id:"report"},"Report"),Object(o.b)("p",null,"Comparing with the two base cases, we can see that all three algorithms are slower than the vanilla js implementation.\nThis result is not particularly surprising as our frameworks add more complexity to the DOM operations through the\ndiffing algorithms. VirtualDOM frameworks will inevitably be slower than normal DOM operations, but the added\ndeveloper experience and functionalities far outweigh the performance loss in mose cases. This benefit is arguable,\nand I will not claim to have the right answer, but I do believe that the improves developer experience creates better\nand more stable software. The end user might see a barely noticeable slow down, but they will also see a less buggy\nand more reactive UI."),Object(o.b)("p",null,"The interesting results for VirtualDOM appear when you compare the duration of each algorithms with React. We can see\nthat the algorithm is often much quicker for some operations, and slightly slower for others. The remaining operations\nhave durations that, if considering the confidence interval, have essentially the same duration. Overall, React is\nfaster (as shown in the geometric mean compared to vanillajs), but VirtualDOM users might see some performance\nimprovement when creating elements. Nothing to brag about, but ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://krausest.github.io/js-framework-benchmark/2020/table_chrome_84.0.4147.89.html"}),"React is also relatively fast compared to other\npopular frameworks"),"."),Object(o.b)("p",null,"Another very interesting result compare to React is the far smaller memory weight and startup time. While the\nperformance might not be anything to scoff at, the framework still manages that performance with a fraction of the\nweight and a similar API."),Object(o.b)("p",null,"Finally, I believe that the slow down seen with VirtualDOM would be seen far less in real world apps compared to\nReact. This is because VirtualDOM components update in isolation, not diffing the entire tree at once. This would\nmake a difference is massive applications as React has to diff the entire tree, starting from the root, to update a\nnode 30 edges deep. The benchmarking tool unfortunately does not catch those types of optimizations."),Object(o.b)("p",null,"Let's go over the results fo each algorithm and see potential problems and optimizations."),Object(o.b)("h3",{id:"recursive"},"Recursive"),Object(o.b)("p",null,"Surprisingly, at least for me, the recursive algorithm is the fastest of all three algorithms. We can notice that\nupdate operations (Replace, swap, partial update) are slower than React. This is likely due to how we set attributes\non DOM nodes. The framework will set both the attribute (",Object(o.b)("inlineCode",{parentName:"p"},"node.setAttribute"),") and the property (",Object(o.b)("inlineCode",{parentName:"p"},"node['property'']"),")\non a node without checking if this is necessary. This was done so to simplify the code and make it future proof, but\nwe could likely keep a reference of attribute names and simplify these operations. Modifying DOM attributes can be\nslow, as is accessing them. Another optimization could be to use the async update system we have for requesting\nupdates. When a component is diffed by the algorithm, it is immediately updated rather than set to update in the\next animation frame, which slow down all those recursive loops."),Object(o.b)("p",null,"One instance where the algorithm shines, however, is when creating elements. Especially when creating up to 10 000\nnodes, we can see that the recursive algorithm can take up to 0.6 seconds less than React! Without analysing the\ncode for React fiber and comparing the performance of each line, it would be hard to theorize as to why that is the\ncase. My personal guess is the weight of component updates in React, and the portability of components in VirtualDOM\nmake creating each row that much faster with VirtualDOM."),Object(o.b)("p",null,"Finally, we could likely optimize this algorithm by changing some of the array methods used. For example, changing\nfrom ",Object(o.b)("inlineCode",{parentName:"p"},"concat")," to ",Object(o.b)("inlineCode",{parentName:"p"},"push")," to add children on a virtual node made quite the difference since ",Object(o.b)("a",Object(r.a)({parentName:"p"},{href:"https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki"}),"concat is slower 945x\nthan push"),"."),Object(o.b)("h3",{id:"iterative"},"Iterative"),Object(o.b)("p",null,"I naively thought a lack of recursion would make the iterative algorithm faster than the recursive alternative,\nbut it ended up being far slower instead. This algorithms is slower than React in all categories except the 10000\nrows one, which is an unlikely case in most apps. Furthermore, it's memory footprint is worse that the other\nalgorithms, which is the opposite of the intended result."),Object(o.b)("p",null,"I believe the cause of all those issues is the stack used to walk the tree. As we just saw in the previous section,\narray operations can be unbelievably slow, and we use an array operation whenever an array has children. Worse, we do\nnot clean the stack. The algorithm uses a simple array to implement its double stack, the ",Object(o.b)("inlineCode",{parentName:"p"},"shift")," function is\nextremely slow, so, to pop our element from the beginning of the stack, we would have to reverse the stack every tme\nwe add children and use ",Object(o.b)("inlineCode",{parentName:"p"},"pop")," on it. ",Object(o.b)("inlineCode",{parentName:"p"},"reverse")," and ",Object(o.b)("inlineCode",{parentName:"p"},"pop")," might be quicker when used together, but they are still far\nslower compare to simply not cleaning the stack."),Object(o.b)("p",null,"Sadly, all those consideration means that we use a lot more memory for no performance gain. We could likely improve\nthis algorithm by using a better stack implementation or finding another way to walk along our two trees."),Object(o.b)("h3",{id:"separated-diff-and-patch-steps-1"},"Separated diff and patch steps"),Object(o.b)("p",null,"The separated algorithms fare a little worse than the recursive algorithm - with the slow downs being safely within\nthe confidence interval - but this is hardly surprising. The walk algorithm is the same as the base recursive\nalgorithm, but we added a new loop and potentially more operations than needed with the patches. This tells us that\nour recursive loop is barely slowed down by the DOM operations and that time would be better spent optimizing the\nrecursive algorithm. In fact, my research shows that most algorithms that claim high performance have merged the\ntwo steps as one of their base optimizations."),Object(o.b)("p",null,"One thing to note is that this algorithm does not use more memory than the base recursive, confirming our\npatches have a very small footprint and do not cause any unnecessary weight."),Object(o.b)("h2",{id:"future-of-the-algorithms"},"Future of the algorithms"),Object(o.b)("p",null,"The benchmarks have shown that the framework's performance is acceptable and using it should not cause any\nperformance issues for the users. Let's identify some areas we could work on to improve performance and detect areas\nof improvement better."),Object(o.b)("p",null,"First, the report has shown that the recursive algorithm is the better algorithm to use within the framework. This is\ndefinitely the algorithm we should focus on when starting to work on performance."),Object(o.b)("p",null,"The next step could potentially be to try to implement keys inside of the framework to improve replace, swap and\ndelete performance. By giving each row a key, it can help to know the order of the diffed tree and make sure we swap\nelements rather than delete and create new ones. Another avenue of improvement are the datastructures and DOM access,\nas explained in the algorithms section."),Object(o.b)("p",null,"Finally, it would be interesting to improve the benchmarking tool to take advantage of the web component aspect of\nthe framework and test if rendering very complex trees and updating deep parts of the tree is faster with VirtualDOM\ncompared to other frameworks like React."))}c.isMDXComponent=!0},75:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return m}));var r=a(0),n=a.n(r);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},o=Object.keys(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)a=o[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var h=n.a.createContext({}),c=function(e){var t=n.a.useContext(h),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=c(e.components);return n.a.createElement(h.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},u=n.a.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,i=e.parentName,h=l(e,["components","mdxType","originalType","parentName"]),p=c(a),u=r,m=p["".concat(i,".").concat(u)]||p[u]||d[u]||o;return a?n.a.createElement(m,s(s({ref:t},h),{},{components:a})):n.a.createElement(m,s({ref:t},h))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var h=2;h<o;h++)i[h]=a[h];return n.a.createElement.apply(null,i)}return n.a.createElement.apply(null,a)}u.displayName="MDXCreateElement"}}]);