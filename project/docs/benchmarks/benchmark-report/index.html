<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="generator" content="Docusaurus v2.0.0-alpha.61">
<title data-react-helmet="true">Benchmarks: Performance report | Project documentation</title><meta data-react-helmet="true" name="twitter:card" content="summary_large_image"><meta data-react-helmet="true" property="og:title" content="Benchmarks: Performance report | Project documentation"><meta data-react-helmet="true" name="description" content="This reports explains the results of the benchmarks found here//minivera.github.io/carleton-web-dev/project"><meta data-react-helmet="true" property="og:description" content="This reports explains the results of the benchmarks found here//minivera.github.io/carleton-web-dev/project"><meta data-react-helmet="true" property="og:url" content="https://minivera.github.io/carleton-web-dev/project/docs/benchmarks/benchmark-report"><link data-react-helmet="true" rel="shortcut icon" href="/carleton-web-dev/project/docs/img/favicon.ico"><link data-react-helmet="true" rel="canonical" href="https://minivera.github.io/carleton-web-dev/project/docs/benchmarks/benchmark-report"><link rel="stylesheet" href="/carleton-web-dev/project/docs/styles.c4f2caf0.css">
<link rel="preload" href="/carleton-web-dev/project/docs/styles.316863d3.js" as="script">
<link rel="preload" href="/carleton-web-dev/project/docs/runtime~main.f4bbde36.js" as="script">
<link rel="preload" href="/carleton-web-dev/project/docs/main.5eeef642.js" as="script">
<link rel="preload" href="/carleton-web-dev/project/docs/1.e11dfcd7.js" as="script">
<link rel="preload" href="/carleton-web-dev/project/docs/2.a5e7c51a.js" as="script">
<link rel="preload" href="/carleton-web-dev/project/docs/21.7d91ea8a.js" as="script">
<link rel="preload" href="/carleton-web-dev/project/docs/1d68c1ea.9947ab1a.js" as="script">
<link rel="preload" href="/carleton-web-dev/project/docs/17896441.f5249667.js" as="script">
<link rel="preload" href="/carleton-web-dev/project/docs/f1bf852f.8413d0cc.js" as="script">
</head>
<body>
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<nav class="navbar navbar--light navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><div aria-label="Navigation bar toggle" class="navbar__toggle" role="button" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" width="30" height="30" viewBox="0 0 30 30" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></div><a class="navbar__brand" href="/carleton-web-dev/project/docs/"><strong class="navbar__title">Project documentation</strong></a><a class="navbar__item navbar__link" href="/carleton-web-dev/project/docs/introduction/getting-started">Getting Started</a><a class="navbar__item navbar__link" href="/carleton-web-dev/project/docs/context/overview">Context</a><a class="navbar__item navbar__link" href="/carleton-web-dev/project/docs/benchmarks/overview">Benchmarks</a><a class="navbar__item navbar__link" href="/carleton-web-dev/project/docs/recipes/recipe-index">Recipes</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/Minivera/carleton-web-dev" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub</a><div class="react-toggle react-toggle--disabled displayOnlyInLargeViewport_2aTZ"><div class="react-toggle-track"><div class="react-toggle-track-check"><span class="toggle_BsTx">ðŸŒœ</span></div><div class="react-toggle-track-x"><span class="toggle_BsTx">ðŸŒž</span></div></div><div class="react-toggle-thumb"></div><input type="checkbox" disabled="" aria-label="Dark mode toggle" class="react-toggle-screenreader-only"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div><div class="navbar-sidebar"><div class="navbar-sidebar__brand"><a class="navbar__brand" href="/carleton-web-dev/project/docs/"><strong class="navbar__title">Project documentation</strong></a></div><div class="navbar-sidebar__items"><div class="menu"><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" href="/carleton-web-dev/project/docs/introduction/getting-started">Getting Started</a></li><li class="menu__list-item"><a class="menu__link" href="/carleton-web-dev/project/docs/context/overview">Context</a></li><li class="menu__list-item"><a class="menu__link" href="/carleton-web-dev/project/docs/benchmarks/overview">Benchmarks</a></li><li class="menu__list-item"><a class="menu__link" href="/carleton-web-dev/project/docs/recipes/recipe-index">Recipes</a></li><li class="menu__list-item"><a href="https://github.com/Minivera/carleton-web-dev" target="_blank" rel="noopener noreferrer" class="menu__link">GitHub</a></li></ul></div></div></div></nav><div class="main-wrapper"><div class="docPage_2gpo"><div class="docSidebarContainer_3_JD" role="complementary"><div class="sidebar_2urC"><div class="menu menu--responsive menu_5FrY"><button aria-label="Open Menu" aria-haspopup="true" class="button button--secondary button--sm menu__button" type="button"><svg aria-label="Menu" class="sidebarMenuIcon_Dm3K" xmlns="http://www.w3.org/2000/svg" height="24" width="24" viewBox="0 0 32 32" role="img" focusable="false"><title>Menu</title><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><ul class="menu__list"><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Introduction</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/">Library overview</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/introduction/getting-started">Getting started</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/introduction/events-conditionals-loops">Events, Conditionals &amp; Loops</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/introduction/applications">Creating applications</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Context</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/context/overview">Context: Introduction</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/context/callbacks">Context: Callbacks</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/context/state-reducer">Context: State with reducers</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/context/react-context">Context: React-like context API</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/context/react-hooks">Context: React-like Hooks API</a></li></ul></li><li class="menu__list-item"><a class="menu__link menu__link--sublist menu__link--active" href="#!">Benchmarks</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="0" href="/carleton-web-dev/project/docs/benchmarks/overview">Benchmarks: Overview</a></li><li class="menu__list-item"><a aria-current="page" class="menu__link menu__link--active active" tabindex="0" href="/carleton-web-dev/project/docs/benchmarks/benchmark-report">Benchmarks: Performance report</a></li></ul></li><li class="menu__list-item menu__list-item--collapsed"><a class="menu__link menu__link--sublist" href="#!">Recipes</a><ul class="menu__list"><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/recipes/recipe-index">Recipes: Index</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/recipes/multiple-hooks">Recipes: Multiple lifecycle hooks per component</a></li><li class="menu__list-item"><a class="menu__link" tabindex="-1" href="/carleton-web-dev/project/docs/recipes/render-prop">Recipes: Render property or function</a></li></ul></li></ul></div></div></div><main class="docMainContainer_3EyW"><div class="container padding-vert--lg docItemWrapper_1EkI"><div class="row"><div class="col docItemCol_2ASc"><div class="docItemContainer_3QWW"><article><header><h1 class="docTitle_1Lrw">Benchmarks: Performance report</h1></header><div class="markdown"><p>This reports explains the results of the benchmarks found here: <a href="https://minivera.github.io/carleton-web-dev/project" target="_blank" rel="noopener noreferrer">https://minivera.github.io/carleton-web-dev/project</a>
/benchmark-data/table.html. Before we dive into the results, let&#x27;s explain the three algorithms used for VirtualDOM.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="algorithms"></a>Algorithms<a aria-hidden="true" tabindex="-1" class="hash-link" href="#algorithms" title="Direct link to heading">#</a></h2><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recursive-algorithm"></a>Recursive algorithm<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recursive-algorithm" title="Direct link to heading">#</a></h3><p>The recursive algorithm uses a simple <code>patch</code> function that is executed on the next animation frame when a component
requests an update. This patch function will look at the old virtual DOM tree and compare it with the newly
generated virtual DOM tree after the component executed the component function with the updated context. By walking
the two trees at the same time, we compare both the old tree node and the new tree node and update the nodes in-place
when we detect changes. We also run the DOM itself at the same time while walking the tree. We keep walking
the tree recursively by calling the <code>patch</code> function on a node&#x27;s children, if it has any.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="iterative-algorithm"></a>Iterative algorithm<a aria-hidden="true" tabindex="-1" class="hash-link" href="#iterative-algorithm" title="Direct link to heading">#</a></h3><p>Recursion in JavaScript can be notoriously problematic with recursion, as each browser have their own &quot;stack limit
&quot;. This means that each browser will, at some point, limit the amount of function you can execute until you return.
In the case of the virtual DOM, it is unlikely a developer will create a 200000 nodes deep virtual tree. However,
the memory weight of all those call stacks can still be a problem for slower devices, and I wanted to see if an
iterative algorithm could be lighter and quicker than a recursive algorithm</p><p>The iterative algorithm works in the same way as the recursive algorithm, but it uses a massive array to stack all
the nodes to visit for both trees, with one stack for each trees. One difference between the two algorithms is the
iterative algorithm will process all of a node&#x27;s children before moving deeper in the tree.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="separated-diff-and-patch-steps"></a>Separated diff and patch steps<a aria-hidden="true" tabindex="-1" class="hash-link" href="#separated-diff-and-patch-steps" title="Direct link to heading">#</a></h3><p>The two previous algorithms modify the virtual and DOM tree in-place while the algorithm runs. This can have the
unintended side effect of slowing down the multiple loops needed for walking the tree for complex operations,
slowing down the tree walk operation. Rather than slow down the tree walking, potentially causing issues in
multiple loops at the same time, this algorithm records the needed changes in small objects called <code>patches</code> and
returns all the patches generated once it has finished executing.</p><p>We use a new loop to loop over all those patches and execute them one by one. With this method, we can be sure
the complex DOM and virtual DOM operations will only execute in one loop. There are some optimizations we can add to
this algorithm that are impossible to add to the other algorithms thanks to this separation, like asynchronous
operations.</p><h2><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="report"></a>Report<a aria-hidden="true" tabindex="-1" class="hash-link" href="#report" title="Direct link to heading">#</a></h2><p>Comparing with the two base cases, we can see that all three algorithms are slower than the vanilla js implementation.
This result is not particularly surprising as our frameworks add more complexity to the DOM operations through the
diffing algorithms. VirtualDOM frameworks will inevitably be slower than normal DOM operations, but the added
developer experience and functionalities far outweigh the performance loss in mose cases. This benefit is arguable,
and I will not claim to have the right answer, but I do believe that the improves developer experience creates better
and more stable software. The end user might see a barely noticeable slow down, but they will also see a less buggy
and more reactive UI.</p><p>The interesting results for VirtualDOM appear when you compare the duration of each algorithms with React. We can see
that the algorithm is often much quicker for some operations, and slightly slower for others. The remaining operations
have durations that, if considering the confidence interval, have essentially the same duration. Overall, React is
faster (as shown in the geometric mean compared to vanillajs), but VirtualDOM users might see some performance
improvement when creating elements. Nothing to brag about, but <a href="https://krausest.github.io/js-framework-benchmark/2020/table_chrome_84.0.4147.89.html" target="_blank" rel="noopener noreferrer">React is also relatively fast compared to other
popular frameworks</a>.</p><p>Another very interesting result compare to React is the far smaller memory weight and startup time. While the
performance might not be anything to scoff at, the framework still manages that performance with a fraction of the
weight and a similar API.</p><p>Finally, I believe that the slow down seen with VirtualDOM would be seen far less in real world apps compared to
React. This is because VirtualDOM components update in isolation, not diffing the entire tree at once. This would
make a difference is massive applications as React has to diff the entire tree, starting from the root, to update a
node 30 edges deep. The benchmarking tool unfortunately does not catch those types of optimizations.</p><p>Let&#x27;s go over the results fo each algorithm and see potential problems and optimizations.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="recursive"></a>Recursive<a aria-hidden="true" tabindex="-1" class="hash-link" href="#recursive" title="Direct link to heading">#</a></h3><p>Surprisingly, at least for me, the recursive algorithm is the fastest of all three algorithms. We can notice that
update operations (Replace, swap, partial update) are slower than React. This is likely due to how we set attributes
on DOM nodes. The framework will set both the attribute (<code>node.setAttribute</code>) and the property (<code>node[&#x27;property&#x27;&#x27;]</code>)
on a node without checking if this is necessary. This was done so to simplify the code and make it future proof, but
we could likely keep a reference of attribute names and simplify these operations. Modifying DOM attributes can be
slow, as is accessing them. Another optimization could be to use the async update system we have for requesting
updates. When a component is diffed by the algorithm, it is immediately updated rather than set to update in the
ext animation frame, which slow down all those recursive loops.</p><p>One instance where the algorithm shines, however, is when creating elements. Especially when creating up to 10 000
nodes, we can see that the recursive algorithm can take up to 0.6 seconds less than React! Without analysing the
code for React fiber and comparing the performance of each line, it would be hard to theorize as to why that is the
case. My personal guess is the weight of component updates in React, and the portability of components in VirtualDOM
make creating each row that much faster with VirtualDOM.</p><p>Finally, we could likely optimize this algorithm by changing some of the array methods used. For example, changing
from <code>concat</code> to <code>push</code> to add children on a virtual node made quite the difference since <a href="https://dev.to/uilicious/javascript-array-push-is-945x-faster-than-array-concat-1oki" target="_blank" rel="noopener noreferrer">concat is slower 945x
than push</a>.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="iterative"></a>Iterative<a aria-hidden="true" tabindex="-1" class="hash-link" href="#iterative" title="Direct link to heading">#</a></h3><p>I naively thought a lack of recursion would make the iterative algorithm faster than the recursive alternative,
but it ended up being far slower instead. This algorithms is slower than React in all categories except the 10000
rows one, which is an unlikely case in most apps. Furthermore, it&#x27;s memory footprint is worse that the other
algorithms, which is the opposite of the intended result.</p><p>I believe the cause of all those issues is the stack used to walk the tree. As we just saw in the previous section,
array operations can be unbelievably slow, and we use an array operation whenever an array has children. Worse, we do
not clean the stack. The algorithm uses a simple array to implement its double stack, the <code>shift</code> function is
extremely slow, so, to pop our element from the beginning of the stack, we would have to reverse the stack every tme
we add children and use <code>pop</code> on it. <code>reverse</code> and <code>pop</code> might be quicker when used together, but they are still far
slower compare to simply not cleaning the stack.</p><p>Sadly, all those consideration means that we use a lot more memory for no performance gain. We could likely improve
this algorithm by using a better stack implementation or finding another way to walk along our two trees.</p><h3><a aria-hidden="true" tabindex="-1" class="anchor enhancedAnchor_2cZh" id="separated-diff-and-patch-steps-1"></a>Separated diff and patch steps<a aria-hidden="true" tabindex="-1" class="hash-link" href="#separated-diff-and-patch-steps-1" title="Direct link to heading">#</a></h3><p>The separated algorithms fare a little worse than the recursive algorithm - with the slow downs being safely within
the confidence interval - but this is hardly surprising. The walk algorithm is the same as the base recursive
algorithm, but we added a new loop and potentially more operations than needed with the patches. This tells us that
our recursive loop is barely slowed down by the DOM operations and that time would be better spent optimizing the
recursive algorithm. In fact, my research shows that most algorithms that claim high performance have merged the
two steps as one of their base optimizations.</p><p>One thing to note is that this algorithm does not use more memory than the base recursive, confirming our
patches have a very small footprint and do not cause any unnecessary weight.</p></div></article><div class="margin-vert--lg"><nav class="pagination-nav" aria-label="Blog list page navigation"><div class="pagination-nav__item"><a class="pagination-nav__link" href="/carleton-web-dev/project/docs/benchmarks/overview"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">Â« Benchmarks: Overview</div></a></div><div class="pagination-nav__item pagination-nav__item--next"><a class="pagination-nav__link" href="/carleton-web-dev/project/docs/recipes/recipe-index"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Recipes: Index Â»</div></a></div></nav></div></div></div><div class="col col--3"><div class="tableOfContents_3klQ"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#algorithms" class="table-of-contents__link">Algorithms</a><ul><li><a href="#recursive-algorithm" class="table-of-contents__link">Recursive algorithm</a></li><li><a href="#iterative-algorithm" class="table-of-contents__link">Iterative algorithm</a></li><li><a href="#separated-diff-and-patch-steps" class="table-of-contents__link">Separated diff and patch steps</a></li></ul></li><li><a href="#report" class="table-of-contents__link">Report</a><ul><li><a href="#recursive" class="table-of-contents__link">Recursive</a></li><li><a href="#iterative" class="table-of-contents__link">Iterative</a></li><li><a href="#separated-diff-and-patch-steps-1" class="table-of-contents__link">Separated diff and patch steps</a></li></ul></li></ul></div></div></div></div></main></div></div><footer class="footer footer--dark"><div class="container"><div class="row footer__links"><div class="col footer__col"><h4 class="footer__title">Docs</h4><ul class="footer__items"><li class="footer__item"><a class="footer__link-item" href="/carleton-web-dev/project/docs/docs/">Documentation</a></li></ul></div><div class="col footer__col"><h4 class="footer__title">More</h4><ul class="footer__items"><li class="footer__item"><a href="https://github.com/Minivera/carleton-web-dev" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub</a></li></ul></div></div><div class="text--center"><div>Copyright Â© 2020 Guillaume St-Pierre. Built with Docusaurus.</div></div></div></footer></div>
<script src="/carleton-web-dev/project/docs/styles.316863d3.js"></script>
<script src="/carleton-web-dev/project/docs/runtime~main.f4bbde36.js"></script>
<script src="/carleton-web-dev/project/docs/main.5eeef642.js"></script>
<script src="/carleton-web-dev/project/docs/1.e11dfcd7.js"></script>
<script src="/carleton-web-dev/project/docs/2.a5e7c51a.js"></script>
<script src="/carleton-web-dev/project/docs/21.7d91ea8a.js"></script>
<script src="/carleton-web-dev/project/docs/1d68c1ea.9947ab1a.js"></script>
<script src="/carleton-web-dev/project/docs/17896441.f5249667.js"></script>
<script src="/carleton-web-dev/project/docs/f1bf852f.8413d0cc.js"></script>
</body>
</html>