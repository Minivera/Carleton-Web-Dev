(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{66:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return i})),n.d(t,"default",(function(){return p}));var a=n(2),r=n(6),c=(n(0),n(73)),o={title:"Context: State with reducers"},s={unversionedId:"context/state-reducer",id:"context/state-reducer",isDocsHomePage:!1,title:"Context: State with reducers",description:"One common pattern with state machines is to use what is called a reducer to process or state based on atomic",source:"@site/docs/context/state-reducer.md",permalink:"/carleton-web-dev/project/docs/context/state-reducer",sidebar:"docs",previous:{title:"Context: Callbacks",permalink:"/carleton-web-dev/project/docs/context/callbacks"},next:{title:"Context: React-like context API",permalink:"/carleton-web-dev/project/docs/context/react-context"}},i=[],u={rightToc:i};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(c.b)("wrapper",Object(a.a)({},u,n,{components:t,mdxType:"MDXLayout"}),Object(c.b)("p",null,"One common pattern with state machines is to use what is called a ",Object(c.b)("inlineCode",{parentName:"p"},"reducer")," to process or state based on atomic\nactions. For example, imagine a counter. We can increment or decrement our counter, but we want to do so in a way\nthat is more predictable than with ",Object(c.b)("inlineCode",{parentName:"p"},"setState"),". We first define some state we want to watch."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const state = { count: 0 };\n")),Object(c.b)("p",null,"Our state is an object with a count property, nothing more. We can then define a function called a reducer, which\ntakes two arguments. One is the current state, and the other is an action. The action is an object containing\nwhatever we need to process the state change, plus an attribute called ",Object(c.b)("inlineCode",{parentName:"p"},"type")," to tell us what the action ",Object(c.b)("em",{parentName:"p"},"is"),". Let's\nwrite what the reducer for our counter should be."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const reducer = (state, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { ...state, count: state.count + 1 };\n    case 'DECREMENT':\n      return { ...state, count: state.count - 1 };\n    default:\n      return state;\n  }\n};\n")),Object(c.b)("p",null,"Reducer are most often defined with a ",Object(c.b)("inlineCode",{parentName:"p"},"switch")," statement. We switch on the action's type, then execute the state\nchange while making sure to create a copy of the previous state. Care must be taken to never mutate the state and\ninstead return a new object altogether. This makes sure state changes are predictable and have no side effects."),Object(c.b)("p",null,"Finally, we define a ",Object(c.b)("inlineCode",{parentName:"p"},"dispatch")," function. This function will take an action and execute our reducer on\nthe current state."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"const dispatch = action => state = reducer(state, action);\n")),Object(c.b)("p",null,"And we're done! With this, we have an easy to reason with system and our counter. Let's see how we can use it with\ncontext and VirtualDOM."),Object(c.b)("pre",null,Object(c.b)("code",Object(a.a)({parentName:"pre"},{className:"language-jsx"}),"/** @jsx h */\nimport { applyContext, h } from 'VirtualDOM';\n\nconst withStateReducer = (defaultState, reducer, component) => {\n  return applyContext(() => ({\n    savedState: defaultState,\n\n    apply({ requestUpdate, ...rest }) {\n      return {\n        ...rest,\n        ...this.savedState,\n        dispatch: action => {\n          this.savedState = reducer(this.savedState, action);\n          requestUpdate();\n        },\n        requestUpdate,\n      };\n    }\n  }), component);\n};\n\n// This is the reducer we used previously\nconst reducer = (state, action) => {\n  switch (action.type) {\n    case 'INCREMENT':\n      return { ...state, count: state.count + 1 };\n    case 'DECREMENT':\n      return { ...state, count: state.count - 1 };\n    default:\n      return state;\n  }\n};\n\nconst Comp = (_, { count, dispatch }) => {\n  return (\n    <div>\n      <h1>Count is: {count}</h1>\n      <button onclick={() => dispatch({ type: 'INCREMENT' })}>Increment</button>\n      <button onclick={() => dispatch({ type: 'DECREMENT' })}>Decrement</button>\n    </div>\n  );\n};\n\nconst Counter = withStateReducer({ count: 0 }, reducer, Comp);\n")),Object(c.b)("p",null,"We can see our state moved to the ",Object(c.b)("inlineCode",{parentName:"p"},"withStateReducer")," call. The dispatch method moved to the context object. Rather\nthan save the state inside of some global object, we instead save it in the context object memory. When the user\ncomponent this dispatch method in one of the buttons, we will update our saved state by executing the reducer and\ntrigger an update."))}p.isMDXComponent=!0},73:function(e,t,n){"use strict";n.d(t,"a",(function(){return l})),n.d(t,"b",(function(){return h}));var a=n(0),r=n.n(a);function c(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){c(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},c=Object.keys(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(a=0;a<c.length;a++)n=c[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=r.a.createContext({}),p=function(e){var t=r.a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=p(e.components);return r.a.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,c=e.originalType,o=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),l=p(n),b=a,h=l["".concat(o,".").concat(b)]||l[b]||d[b]||c;return n?r.a.createElement(h,s(s({ref:t},u),{},{components:n})):r.a.createElement(h,s({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var c=n.length,o=new Array(c);o[0]=b;var s={};for(var i in t)hasOwnProperty.call(t,i)&&(s[i]=t[i]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var u=2;u<c;u++)o[u]=n[u];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);