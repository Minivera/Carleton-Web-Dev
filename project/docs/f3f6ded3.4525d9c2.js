(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{72:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return l})),n.d(t,"default",(function(){return p}));var a=n(2),r=n(6),o=(n(0),n(75)),c={title:"Context: Callbacks"},i={unversionedId:"context/callbacks",id:"context/callbacks",isDocsHomePage:!1,title:"Context: Callbacks",description:"As we've seen in the context overview, context objects can be used to make sure callbacks are only executed once. Let's",source:"@site/docs/context/callbacks.md",permalink:"/carleton-web-dev/project/docs/context/callbacks",sidebar:"docs",previous:{title:"Context: Introduction",permalink:"/carleton-web-dev/project/docs/context/overview"},next:{title:"Context: State with reducers",permalink:"/carleton-web-dev/project/docs/context/state-reducer"}},l=[],s={rightToc:l};function p(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"As we've seen in the context overview, context objects can be used to make sure callbacks are only executed once. Let's\nreview this example ans see if there are any ways to improve this behavior to be even more useful."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"export const withCallback = (callback, component) => {\n  return applyContext(() => ({\n    apply(context) {\n      return {\n        ...context,\n        afterMount: callback,\n      };\n    }\n  }), component);\n};\n\nconst AugmentedComponent = withCallback(() => {\n  // Do something, but only once!\n}, component);\n")),Object(o.b)("p",null,"In its simplest form, this context allows a developer to provide a callback and this callback, and it will only be\nexecuted once after the component has mounted. What if we wanted to call this callback again in case something\nchanges on the component? For example, if we fetch a user with this callback, we might want to trigger the fetch\nagain if the id ever changes. We can do this easily by using the context memory."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-javascript"}),"// TODO validate this example\nexport const withMemoizedCallback = (callback, dependencies, component) => {\n  return applyContext(() => ({\n    watched: {},\n    watching: false,\n\n    triggerCallback(context) {\n      const merged = {...this.props, ...context};\n\n      // If we are watching\n      if (this.watching) {\n        if (Object.keys(merged).filter(key => dependencies.includes(keys)).find(\n          key => watched[key] !== merged[key])\n        ) {\n          // Check if any of the keys we watch, and if we find one that doesn't match,\n          // trigger the watching process again\n          this.watching = false;\n        }\n      }\n\n      if (!this.watching) {\n        callback.call(this, context);\n        this.watching = true;\n    \n        // Save the values of the watched dependencies, if they exist\n        Object.keys(merged).filter(key => dependencies.includes(keys)).forEach(key => {\n          watched[key] = merged[key];\n        });\n      }\n    },\n\n    apply(context) {\n      return {\n        ...context,\n        afterMount: triggerCallback,\n        afterUpdate: triggerCallback,\n      };\n    }\n  }), component);\n};\n\nconst AugmentedComponent = withCallback(() => {\n  // Do something at mount time and every time userId changes.\n  fetch(`/api/${this.props.userid}`).then(...);\n}, ['userid'], component)\n")),Object(o.b)("p",null,"Lots to unpack here. Before we do so, you can see that, in this example, we use the context object to store our watched\nattributes. We could very easily use state here, but this would expose our watched attributes in the context."),Object(o.b)("p",null,"Let's first look at the ",Object(o.b)("inlineCode",{parentName:"p"},"apply")," function, here we simply return the context with two hooks set. We want to make sure\nto trigger the callback on mount, but also on every update, so we can retrigger said callback if our attributes\nchange."),Object(o.b)("p",null,"Next, we have the ",Object(o.b)("inlineCode",{parentName:"p"},"triggerCallback")," function. This function is divided into two parts. The second part, starting at\nthe ",Object(o.b)("inlineCode",{parentName:"p"},"if (!this.watching) {")," statement, will trigger the callback if we are not waiting for the attributes to change\n. It will also save the value of the properties or context elements we are watching when the callback triggers."),Object(o.b)("p",null,"The first part of the function will be executed on every update as long as we are watching for changes. It will\ncompare the context and properties of the component with the values we were saving previously and trigger a new\nwatch cycle if those ever change."))}p.isMDXComponent=!0},75:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=r.a.createContext({}),p=function(e){var t=r.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=p(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),u=p(n),b=a,d=u["".concat(c,".").concat(b)]||u[b]||h[b]||o;return n?r.a.createElement(d,i(i({ref:t},s),{},{components:n})):r.a.createElement(d,i({ref:t},s))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,c=new Array(o);c[0]=b;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,c[1]=i;for(var s=2;s<o;s++)c[s]=n[s];return r.a.createElement.apply(null,c)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);