{"mappings":"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","sources":["src/project/vdom/nodes/htmlNode.js","src/project/vdom/nodes/textNode.js","src/project/vdom/nodes/treeNode.js","src/project/vdom/diffing/patchTree.js","src/project/vdom/tree/component.js","src/project/vdom/utils/flattenArray.js","src/project/vdom/nodes/factory.js","node_modules/classnames/index.js","src/project/demo/components/footer.jsx","/home/runner/work/carleton-web-dev/carleton-web-dev/node_modules/@parcel/scope-hoisting/lib/helpers.js","src/project/demo/components/todoItem.jsx","src/project/demo/model/todoModel.js","src/project/demo/index.jsx","src/project/vdom/index.js","src/project/demo/components/app.jsx"],"names":["HtmlNode","_ref","tag","attributes","children","$c483bf5af8290f2cd662c50f1336bd$var$_classCallCheck","this","domNode","other","Object","entries","find","_ref2","_ref3","$c483bf5af8290f2cd662c50f1336bd$var$_slicedToArray","key","value","length","TextNode","text","$ab51a5e78fa39f5c0b7d5925fb737f05$var$_classCallCheck","TreeNode","factory","$a34c81a8396481576d56101484e55d4$var$_classCallCheck","$a34c81a8396481576d56101484e55d4$var$_slicedToArray","applyAttributes","oldAttributes","arguments","undefined","newAttributes","node","keys","forEach","prototype","hasOwnProperty","call","removeAttribute","$f6663bccd22350ea64877355572b61e2$var$_slicedToArray","setAttribute","generateNode","virtualNode","$c483bf5af8290f2cd662c50f1336bd$export$HtmlNode","document","createElement","$ab51a5e78fa39f5c0b7d5925fb737f05$export$TextNode","createTextNode","$a34c81a8396481576d56101484e55d4$export$TreeNode","rootElement","setAll","patch","parent","oldNode","newNode","child","appendChild","map","replaceChild","diff","nodeValue","updateNode","update","oldChildrenQueue","$f6663bccd22350ea64877355572b61e2$var$_toConsumableArray","reverse","newChildrenQueue","index","oldChild","pop","slice","removeChild","newChild","_loop","push","ComponentElement","window","HTMLElement","_this","$bd7c0fa29be02bde8091569334a2372a$var$_classCallCheck","_super","mounted","props","virtualChild","contextCreator","context","setState","requestUpdate","lifecycleListeners","afterConnect","beforeMount","afterMount","beforeUpdate","shouldUpdate","afterUpdate","beforeDisconnect","tree","applyContext","mount","_this2","finalContext","$bd7c0fa29be02bde8091569334a2372a$var$_objectSpread","bind","hook","listen","listener","render","$f6663bccd22350ea64877355572b61e2$export$patch","vtree","customElements","define","flatten","input","stack","$b4004002b7d326e5c6469a6a5b468$var$_toConsumableArray","res","next","Array","isArray","apply","vdonizeChildren","createNode","_len","_key","flatChildren","$b4004002b7d326e5c6469a6a5b468$export$flatten","hasOwn","classNames","classes","i","arg","argType","inner","join","$dc5118610df5cc910ea040e1de8e$exports","default","a","__esModule","Footer","count","completedCount","nowShowing","setNowShowing","clearCompleted","activeTodoWord","clearButton","$efe9a6cdc457f0954e90dd2137a671e0$export$createNode","class","onclick","$dc5118610df5cc910ea040e1de8e$$interop$default","selected","TodoItem","todo","model","_ref2$isEditing","isEditing","_ref2$editTodo","editTodo","title","setIsEditing","val","setEditTodo","handleSubmit","trim","id","completed","editing","type","checked","onchange","toggle","ondblclick","removeTodo","onblur","oninput","event","target","onkeydown","preventDefault","currentId","root","renderInto","element","Error","_","_ref$todos","todos","_ref$newTodo","newTodo","_ref$nowShowing","setNewTodo","setTodos","addTodo","concat","newTitle","$b9d57fa8a5c1de4aab41f5e867bd$var$_objectSpread","filter","all","$b9d57fa8a5c1de4aab41f5e867bd$var$_toConsumableArray","toggleAll","$b9d57fa8a5c1de4aab41f5e867bd$export$default","allTodos","shownTodos","activeTodoCount","reduce","accum","placeholder","autoFocus","htmlFor","$a4640d8033a36054353575a1596c$export$TodoItem","$aaa9c2a41b10e743c5ff0e575e69d19$export$Footer","querySelector"],"version":3,"file":"demo.013f9a2a.js.map","sourcesContent":["/**\n * HTML node class that manages an HTML element in the virtual Tree.\n * @todo Support SVGs\n * @export\n * @class HtmlNode\n */\nexport class HtmlNode {\n  /**\n   * Class constructor that stores the values.\n   * @param {Object} props - The properties given to this constructor.\n   * @param {String} props.tag - Tag name to create in the DOM when this node is mounted.\n   * @param {object} props.attributes - Attributes to assign to the HTML node when created.\n   * @param {(TreeNode|HtmlNode|TextNode)[]} props.children - The children to assign to the HTML node when created.\n   */\n  constructor({ tag, attributes, children }) {\n    /**\n     * Tag for creating the HTMLElement in the DOM when mounting.\n     * @type {String}\n     */\n    this.tag = tag;\n\n    /**\n     * Attributes to assign to the HTMLElement when mounting or updating.\n     * @type {Object}\n     */\n    this.attributes = attributes;\n\n    /**\n     * Virtual children that will have to be patched into the virtual DOM node when mounting or updating.\n     * @type {(TreeNode|HtmlNode|TextNode)[]}\n     */\n    this.children = children;\n\n    /**\n     * DOM node assigned to this virtual node for easy access.\n     * @type {HTMLElement}\n     */\n    this.domNode = null;\n  }\n\n  /**\n   * Diffing function that returns if the two nodes are the same or not.\n   * @param other {TreeNode|HtmlNode|TextNode}\n   * @returns {boolean} Returns true if the two nodes are the same, false otherwise.\n   */\n  diff(other) {\n    if (!(other instanceof HtmlNode)) {\n      return false;\n    }\n    if (this.tag !== other.tag) {\n      return false;\n    }\n    if (Object.entries(this.attributes).find(([key, value]) => other.attributes[key] !== value)) {\n      return false;\n    }\n    return this.children.length === other.children.length;\n  }\n}\n","/**\n * Text node class that manages a text element in the virtual Tree.\n * @export\n * @class TextNode\n */\nexport class TextNode {\n  /**\n   * Class constructor that stores the values.\n   * @param {Object} props - The properties given to this constructor.\n   * @param {String} props.text - Text to display through this virtual node.\n   */\n  constructor({ text }) {\n    /**\n     * Stores the text to display in the DOM when mounted or updated.\n     * @type {String}\n     */\n    this.text = text;\n\n    /**\n     * DOM node assigned to this virtual node for easy access.\n     * @type {Text}\n     */\n    this.domNode = null;\n  }\n\n  /**\n   * Diffing function that returns if the two nodes are the same or not.\n   * @param other {TreeNode|HtmlNode|TextNode}\n   * @returns {boolean} Returns true if the two nodes are the same, false otherwise.\n   */\n  diff(other) {\n    if (!(other instanceof TextNode)) {\n      return false;\n    }\n    return this.text === other.text;\n  }\n}\n","import '../utils/typeDef';\n\n/**\n * Tree node class that manages component based classes. When the node creator hits a function, it will\n * create an instance of this class.\n * @export\n * @class TreeNode\n */\nexport class TreeNode {\n  /**\n   * Class constructor that stores the values.\n   * @param {Object} props - The properties given to this constructor.\n   * @param {functionComponent} props.factory - Component to build when this node is rendered in the view.\n   * @param {object} props.attributes - Attributes to pass to the factory when called.\n   * @param {(TreeNode|HtmlNode|TextNode)[]} props.children - The children to pass to the factory when called.\n   */\n  constructor({ factory, attributes, children }) {\n    /**\n     * Stores the factory used to render this component.\n     * @type {functionComponent}\n     */\n    this.factory = factory;\n\n    /**\n     * The attributes assigned to this node, will be passed to the factory when it is executed.\n     * @type {Object}\n     */\n    this.attributes = attributes;\n\n    /**\n     * Children of the node. Will be passed to the factory when it is execute. Not to confuse with the children\n     * rendered by the factory.\n     * @type {(TreeNode|HtmlNode|TextNode)[]}\n     */\n    this.children = children;\n\n    /**\n     * DOM node assigned to this virtual node for easy access.\n     * @type {HTMLElement}\n     */\n    this.domNode = null;\n  }\n\n  /**\n   * Diffing function that returns if the two nodes are the same or not.\n   * @param other {TreeNode|HtmlNode|TextNode}\n   * @returns {boolean} Returns true if the two nodes are the same, false otherwise.\n   */\n  diff(other) {\n    if (!(other instanceof TreeNode)) {\n      return false;\n    }\n    if (Object.entries(this.attributes).find(([key, value]) => other.attributes[key] !== value)) {\n      return false;\n    }\n    return this.factory === other.factory;\n  }\n}\n","import { HtmlNode } from '../nodes/htmlNode';\nimport { TextNode } from '../nodes/textNode';\nimport { TreeNode } from '../nodes/treeNode';\n\n/**\n * Function that will apply the given attributes on the HTML element. The old attributes are passed for removing\n * attributes when needed. For example, if an attribute is present in the old attributes, but not in the new\n * attributes, it should be removed from the DOM node.\n * @todo support namespaced attributes\n * @param {Object} oldAttributes - The old attributes that were assigned to the node before the patch.\n * @param {Object} newAttributes - The new attributes that were assigned to the node after the patch.\n * @param {HTMLElement} node - The node on which to apply the attribute changes.\n */\nconst applyAttributes = (oldAttributes = {}, newAttributes = {}, node) => {\n  Object.keys(oldAttributes).forEach(key => {\n    // If the new attributes doesn't have the old attribute\n    if (!Object.prototype.hasOwnProperty.call(newAttributes, key) || !newAttributes[key]) {\n      // Remove the attribute from the node since it is now gone\n      if (typeof node[key] !== 'undefined') {\n        // Delete on the node directly if we can\n        delete node[key];\n      }\n      node.removeAttribute(key);\n    }\n  });\n  // Go over the new attributes\n  Object.entries(newAttributes).forEach(([key, value]) => {\n    if (typeof value !== 'function' && Object.prototype.hasOwnProperty.call(oldAttributes, key) &&\n      oldAttributes[key] === value) {\n      // If the attribute did not change and is not an event listener, don't bother updating\n      return;\n    }\n    if (typeof node[key] !== 'undefined') {\n      // Set on the node directly if we can\n      node[key] = value;\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n      // Set the new attribute value on the node\n      node.setAttribute(key, value);\n    } else if (typeof value === 'boolean') {\n      // For booleans, set the attribute as an empty string if true or remove if false\n      if (value) {\n        node.setAttribute(key, '');\n      } else {\n        node.removeAttribute(key);\n      }\n    }\n  });\n};\n\n/**\n * Generate a DOM node with the given virtual node. If generating a virtual dom component, it will also assign\n * all the properties on the web component.\n * @param {HtmlNode|TextNode|TreeNode} virtualNode - The node from which to create the DOM node.\n * @returns {Node} - Returns a DOM node that can be used directly.\n */\nconst generateNode = virtualNode => {\n  if (virtualNode instanceof HtmlNode) {\n    return document.createElement(virtualNode.tag);\n  } else if (virtualNode instanceof TextNode) {\n    return document.createTextNode(virtualNode.text);\n  } else if (virtualNode instanceof TreeNode) {\n    const rootElement = document.createElement('vdom-component');\n    rootElement.setAll(virtualNode.factory, virtualNode.attributes, virtualNode.children, virtualNode);\n    return rootElement;\n  }\n};\n\n/**\n * Updates a virtual node and its associated DOM node with the values of the new virtual node.\n * @param {HtmlNode|TextNode|TreeNode} oldNode - The node to update.\n * @param {HtmlNode|TextNode|TreeNode} newNode - The node to update from.\n */\nconst updateNode = (oldNode, newNode) => {\n  if (oldNode instanceof HtmlNode) {\n    applyAttributes(oldNode.attributes, newNode.attributes, oldNode.domNode);\n    oldNode.attributes = newNode.attributes;\n  } else if (oldNode instanceof TextNode) {\n    oldNode.text = newNode.text;\n    oldNode.domNode.nodeValue = newNode.text;\n  } else if (oldNode instanceof TreeNode) {\n    // Update the virtual attributes for a component node\n    oldNode.attributes = newNode.attributes;\n    oldNode.children = newNode.children;\n    oldNode.factory = newNode.factory;\n    // Update the DOM attributes from the associated web component\n    oldNode.domNode.setAll(newNode.factory, newNode.attributes, newNode.children, oldNode);\n  }\n};\n\n/**\n * Main diffing algorithm that will diff nodes and patch them in place, generating DOM mutations alongside virtual DOM\n * mutations. Will be recursively called on all the nodes in the tree until the entire tree has been patched.\n * @param {HtmlNode|TextNode|TreeNode} parent - The parent of the old and new node. Used to add or remove children.\n * @param {HtmlNode|TextNode|TreeNode} oldNode - The node from the tree that is being patched. Is modified by the\n * algorithm.\n * @param {HtmlNode|TextNode|TreeNode} newNode - The node from the new tree used to patch the old tree.\n * @export\n */\nexport const patch = (parent, oldNode, newNode) => {\n  // If Old node does not exists, then we are mounting for the first time\n  if (!oldNode) {\n    // Generate the dom node\n    const domNode = generateNode(newNode);\n    newNode.domNode = domNode;\n    if (newNode instanceof HtmlNode) {\n      applyAttributes({}, newNode.attributes, domNode);\n    }\n\n    // Start patching on the new node's children\n    if (newNode.children) {\n      newNode.children.forEach(child => patch(newNode, null, child));\n    }\n    parent.domNode.appendChild(domNode);\n    return;\n  }\n\n  // If the two nodes don't have the same type\n  if (oldNode.prototype !== newNode.prototype) {\n    // Replace the old child with the new child\n    parent.children = parent.children.map(child => {\n      if (child === oldNode) {\n        return newNode;\n      }\n      return child;\n    });\n    const domNode = generateNode(newNode);\n    newNode.domNode = domNode;\n    if (newNode instanceof HtmlNode) {\n      applyAttributes(oldNode.attributes, newNode.attributes, domNode);\n    }\n    if (!(newNode instanceof TreeNode)) {\n      // Start patching the new node if they are not components\n      // If they are components, the connectedCallback function will take care of the rest\n      patch(parent, null, newNode);\n    }\n    parent.domNode.replaceChild(domNode, oldNode.domNode);\n  }\n\n  // If the nodes are different, but of the same type\n  if (!oldNode.diff(newNode)) {\n    // Update the nodes\n    updateNode(oldNode, newNode);\n    if (oldNode instanceof TreeNode) {\n      // If this node is a component, stop right here and update the component.\n      // The component will take care of patching the children\n      oldNode.domNode.update();\n      return;\n    }\n  }\n\n  // Proceed to update the children or replace them if needed\n  const oldChildrenQueue = [...(oldNode && oldNode.children ? oldNode.children : [])].reverse();\n  const newChildrenQueue = [...(newNode && newNode.children ? newNode.children : [])].reverse();\n  let index = 0;\n  // Loop in the old children until we have no more children\n  while (oldChildrenQueue.length) {\n    const oldChild = oldChildrenQueue.pop();\n    // If there are no more new children\n    if (!newChildrenQueue.length) {\n      // We have to remove the remaining old children and break the loop\n      oldNode.children.slice(index).forEach(child => {\n        oldNode.domNode.removeChild(child.domNode);\n      });\n      oldNode.children = oldNode.children.slice(0, index);\n      break;\n    }\n\n    index++;\n    const newChild = newChildrenQueue.pop();\n\n    // Start patching the two nodes\n    patch(oldNode, oldChild, newChild);\n  }\n\n  // Loop in the new children if there are more\n  while (newChildrenQueue.length) {\n    const newChild = newChildrenQueue.pop();\n    oldNode.children.push(newChild);\n\n    // Generate the new node and append it to the dom\n    const domNode = generateNode(newChild);\n    newChild.domNode = domNode;\n    if (newChild instanceof HtmlNode) {\n      applyAttributes({}, newChild.attributes, domNode);\n    }\n\n    // Start patching the new node's children\n    if (newChild.children) {\n      newChild.children.forEach(child => patch(newChild, null, child));\n    }\n    oldNode.domNode.appendChild(domNode);\n  }\n};\n","import { patch } from '../diffing/patchTree';\nimport '../utils/typeDef';\n\n/**\n * Custom element that allows us to manage components as trees rather than nodes of a tree. These components\n * are stored inside of the actual DOM and keep their own virtual tree. When one is added to the DOM structure,\n * it will render the function stored in factory and mount the virtual nodes into the DOM.\n * @export\n * @class ComponentElement\n * @extends window.HTMLElement\n */\nclass ComponentElement extends window.HTMLElement {\n  /**\n   * Class constructor.\n   */\n  constructor() {\n    super();\n\n    /**\n     * Stores whether or not the component has mounted the content of its factory. Will not update\n     * if it has yet to be mounted.\n     * @type {boolean}\n     */\n    this.mounted = false;\n\n    /**\n     * Stores the properties of the component given as attributes when the `createNode` function is called.\n     * @type {{}}\n     */\n    this.props = {};\n\n    /**\n     * Stores the virtual children that are to be passed to the factory when rendering.\n     * @type {TreeNode|TextNode|HtmlNode}\n     */\n    this.virtualChild = null;\n\n    /**\n     * The factory to execute when this component mounts or update.\n     * @type {functionComponent}\n     */\n    this.factory = () => null;\n\n    /**\n     * The context is a special function that takes in a context object and will return a context object. By executing\n     * the given function, it will run the `apply` function on each of the context objects applied on the component and\n     * return the updated context to augment the component with.\n     * @type {function(Object): Object}\n     */\n    this.contextCreator = context => context;\n\n    /**\n     * Object that stores the component's context data. Updated with state management capabilities for the framework.\n     * @type {{}}\n     */\n    this.context = {\n      setState: (key, value) => {\n        this.context[key] = value;\n        this.requestUpdate();\n      },\n    };\n\n    /**\n     * Object containing lifecycle listener functions.\n     * @typedef lifecycleListeners\n     * @property {function(ComponentElement)} beforeMount - Hook called after the component has been connected to\n     * the DOM and before it is mounted.\n     * @property {function(ComponentElement)} afterMount - Hook called after the component has been successfully\n     * mounted.\n     * @property {function(ComponentElement)} beforeUpdate - Hook called before the component is updated and before\n     * checking if we should update.\n     * @property {function(ComponentElement): boolean} shouldUpdate - Hook called before the component is updated.\n     * Return false to prevent updating the component. Does not provide the old or new attributes, the developer\n     * is in charge of keep track of those.\n     * @property {function(ComponentElement)} afterUpdate - Hook called after an update has been processed.\n     * @property {function(ComponentElement)} beforeDisconnect - Hook called before the component is disconnected\n     * from the DOM.\n     */\n\n    /**\n     * Object containing functions that listen to the various lifecycle events of a component. These functions\n     * will be executed with the current component as their only parameter.\n     * @type {lifecycleListeners}\n     */\n    this.lifecycleListeners = {\n      afterConnect: () => {},\n      beforeMount: () => {},\n      afterMount: () => {},\n      beforeUpdate: () => {},\n      shouldUpdate: () => true,\n      afterUpdate: () => {},\n      beforeDisconnect: () => {},\n    };\n\n    /**\n     * The tree mounted on this component. When the component updates, this tree is updated in place.\n     * @type {TreeNode|TextNode|HtmlNode}\n     */\n    this.tree = null;\n\n    /**\n     * The TreeNode instance for this component to make sure the two can properly communicate.\n     * @type {TreeNode}\n     */\n    this.node = null;\n  }\n\n  /**\n   * Update the values of the DOM component from the values passed in parameter.\n   * @param {functionComponent} factory - Function to render the component.\n   * @param {{}} props - Properties to give to the factory.\n   * @param {TreeNode|TextNode|HtmlNode} virtualChild - Child to give to the factory.\n   * @param {TreeNode} node - Underlying virtual node backing the DOM node.\n   */\n  setAll(factory, props, virtualChild, node) {\n    this.factory = factory;\n    this.contextCreator = this.factory.contextCreator || (context => context);\n    this.props = props;\n    this.virtualChild = virtualChild;\n    this.node = node;\n\n    this.applyContext();\n  }\n\n  /**\n   * The lifecycle method called by the DOM. Will use the fact that the node has been added to the DOM to\n   * mount the content of the factory.\n   */\n  connectedCallback() {\n    this.mount();\n  }\n\n  /**\n   * The lifecycle method called by the DOM with the component is disconnected from it.\n   */\n  disconnectedCallback() {\n    this.lifecycleListeners.beforeDisconnect(this);\n    this.mounted = false;\n  }\n\n  /**\n   * Method that executes the context creator on this nodeand saves the updated context.\n   */\n  applyContext() {\n    // Generate the context from the previous context\n    const finalContext = this.contextCreator({\n      ...this.context,\n      requestUpdate: this.requestUpdate.bind(this),\n    });\n\n    // Loop on each of the available lifecycle hooks\n    [\n      'afterConnect',\n      'beforeMount',\n      'afterMount',\n      'beforeUpdate',\n      'shouldUpdate',\n      'afterUpdate',\n      'beforeDisconnect'\n    ].forEach(hook => {\n      // If the context object has a hook defined and it is a function\n      if (finalContext[hook] && typeof finalContext[hook] === 'function') {\n        // Add that lifecycle hook to the component properties\n        this.listen(hook, finalContext[hook]);\n        delete finalContext[hook];\n      }\n    });\n\n    // Update the element context with the new context.\n    this.context = finalContext;\n  }\n\n  /**\n   * Function that sets a specific lifecycle hook listener. Will do nothing if the lifecycle hook\n   * is unknown.\n   * @see lifecycleListeners\n   * @param {String} hook - Hook to listen to.\n   * @param {function} listener - Listener function to set for the given hook.\n   */\n  listen(hook, listener) {\n    if (Object.prototype.hasOwnProperty.call(this.lifecycleListeners, hook)) {\n      this.lifecycleListeners[hook] = listener;\n    }\n  }\n\n  /**\n   * Mount method that is triggered when the component is mounted to the DOM. Will render the tree for the first time\n   * and diff it against the empty DOM.\n   */\n  mount() {\n    this.lifecycleListeners.beforeMount(this);\n    this.tree = this.render();\n    this.mounted = true;\n    patch(this.node, null, this.tree);\n    this.lifecycleListeners.afterMount(this);\n  }\n\n  /**\n   * Requests and update on the component that will trigger and update if the component is still mounted.\n   * @todo Add ability to batch updates\n   */\n  requestUpdate() {\n    if (this.mounted) {\n      this.applyContext();\n      this.update();\n    }\n  }\n\n  /**\n   * Update method that will trigger a new render of this virtual tree and execute the diffing algorithm.\n   */\n  update() {\n    this.lifecycleListeners.beforeUpdate(this);\n    if (!this.lifecycleListeners.shouldUpdate(this)) {\n      return;\n    }\n    const vtree = this.render();\n    patch(this.node, this.tree, vtree);\n    this.lifecycleListeners.afterUpdate(this);\n  }\n\n  /**\n   * Render method used to render the factory using the component's state and properties.\n   * @private\n   * @returns {TreeNode|TextNode|HtmlNode} Returns the rendered factory.\n   */\n  render() {\n    return this.factory({\n      ...this.props,\n      children: this.virtualChild,\n    }, this.context);\n  }\n}\n\nwindow.customElements.define('vdom-component', ComponentElement);\n","/**\n * Utility method that will flatten an array with infinite depth down to a single continuous array.\n * This method will remove any null or empty elements without modifying the original array.\n * @param input {Array} - The input array to flatten.\n * @returns {*[]} The flattened array without any nulls or undefined.\n */\nexport const flatten = input => {\n  // Create a stack with all the inputs\n  const stack = [...input];\n  const res = [];\n  // While there are elements in the stack\n  while (stack.length) {\n    // Pop value from stack\n    const next = stack.pop();\n    if (Array.isArray(next)) {\n      // Push back array items without modifying the original input\n      stack.push(...next);\n    } else if (next !== null && typeof next !== 'undefined') {\n      // If the next element is not an array, make sure it is not null or undefined.\n      res.push(next);\n    }\n  }\n\n  // Reverse to restore input order, adding at the end of an array is far more performant than adding at the beginning.\n  return res.reverse();\n};\n","import { TreeNode } from './treeNode';\nimport { TextNode } from './textNode';\nimport { HtmlNode } from './htmlNode';\nimport { flatten } from '../utils/flattenArray';\n\n/**\n * Transform all children that are not object readable bu the `createNode` function into an object\n * that can ve processed by that same function. In particular, it makes sure that you can pass a string as\n * a children and still get a valid node.\n *\n * This enables something like:\n * @example\n *   createNode(\"span\", {}, \"Hello, world!\");\n * @param child {*} - The children the manage. This function is intended to be called within a `.map` call.\n * @returns {TreeNode|TextNode|HtmlNode|*} Returns a valid virtual node.\n */\nconst vdonizeChildren = child =>\n  typeof child === 'string' || typeof child === 'number' || typeof child === 'boolean'\n    ? createNode({ text: child }, {}) : child;\n\n/**\n * This factory method takes JSX compliant parameters and generate small objects that represent our\n * virtual nodes. By walking this tree of nodes, we can process the virtual DOM tree and mount in on the DOM.\n *\n * If given a string as the tag, it will render an HTML node. Text nodes are managed through the `vdonizeChildren`\n * method, meaning that your only way to create text nodes is by giving a text children to another node. It also means\n * that the root node of an application cannot be a text node.\n *\n * If given a function as the tag, the creator will return a TreeNode to generate a new subtree and\n * execute the component.\n *\n * @example\n * createNode(({ text }) => createNode(\"h1\", { style: \"color: red;\" }, text), { text: \"Hello, World!\" });\n * @param tag {String|Function|{ text: String }} - The tag of this virtual node.\n * @param attributes {Object} - The attributes of the node if it needs any. Only components and HTML nodes use\n * attributes.\n * @param children {TreeNode|TextNode|HtmlNode|String} - the children to pass to the virtual node if it needs any.\n * Text nodes will ignore the children parameter if they are given some.\n * @returns {TreeNode|TextNode|HtmlNode} Returns a valid virtual node.\n * @export\n */\nexport const createNode = (tag, attributes = {}, ...children) => {\n  // protect against null attributes\n  let props = attributes || {};\n\n  // Remove attributes added by JSX in development\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-unused-vars\n    const { __self, __source, ...rest } = props;\n    props = rest;\n  }\n\n  // Flatten the children so that any array created with things like .map are processed as a single continuous array.\n  // TODO: This might be inefficient long term.\n  const flatChildren = flatten(children);\n  if (typeof tag === 'function') {\n    return new TreeNode({\n      factory: tag,\n      attributes: props,\n      children: flatChildren.map(vdonizeChildren),\n    });\n  }\n  if (Object.prototype.hasOwnProperty.call(tag, 'text')) {\n    return new TextNode({ text: tag.text });\n  }\n\n  return new HtmlNode({\n    tag,\n    attributes: props,\n    children: flatChildren.map(vdonizeChildren),\n  });\n};\n","/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","/** @jsx h */\nimport { h } from '../../vdom';\nimport classNames from 'classnames';\n\nconst ALL_TODOS = 'all';\nconst ACTIVE_TODOS = 'active';\nconst COMPLETED_TODOS = 'completed';\n\nexport const Footer = ({ count, completedCount, nowShowing, setNowShowing, clearCompleted }) => {\n  const activeTodoWord = count > 1 ? 'items' : 'item';\n\n  let clearButton = null;\n  if (completedCount > 0) {\n    clearButton = (\n      <button\n        class=\"clear-completed\"\n        onclick={clearCompleted}>\n        Clear completed\n      </button>\n    );\n  }\n\n  return (\n    <footer class=\"footer\">\n      <span class=\"todo-count\">\n        <strong>{count}</strong> {activeTodoWord} left\n      </span>\n      <ul class=\"filters\">\n        <li>\n          <a\n            onclick={() => setNowShowing(ALL_TODOS)}\n            class={classNames({ selected: nowShowing === ALL_TODOS })}>\n            All\n          </a>\n        </li>\n        {' '}\n        <li>\n          <a\n            onclick={() => setNowShowing(ACTIVE_TODOS)}\n            class={classNames({ selected: nowShowing === ACTIVE_TODOS })}>\n            Active\n          </a>\n        </li>\n        {' '}\n        <li>\n          <a\n            onclick={() => setNowShowing(COMPLETED_TODOS)}\n            class={classNames({ selected: nowShowing === COMPLETED_TODOS })}>\n            Completed\n          </a>\n        </li>\n      </ul>\n      {clearButton}\n    </footer>\n  );\n};\n",null,"/** @jsx h */\nimport { h } from '../../vdom';\nimport classNames from 'classnames';\n\nexport const TodoItem = ({ todo, model }, { isEditing = false, editTodo = todo.title, setState }) => {\n  const setIsEditing = val => setState('isEditing', val);\n  const setEditTodo = val => setState('editTodo', val);\n\n  const handleSubmit = () => {\n    const val = editTodo.trim();\n\n    if (val) {\n      model.editTodo(todo.id, val);\n      setIsEditing(false);\n    }\n  };\n\n  const handleChange = event => {\n    setEditTodo(event.target.value);\n  };\n\n  const handleStartEditing = () => {\n    setEditTodo(todo.title);\n    setIsEditing(true);\n  };\n\n  const handleKeyDown = event => {\n    if (event.key !== 'Enter') {\n      return;\n    }\n\n    event.preventDefault();\n    handleSubmit();\n  };\n\n  return (\n    <li class={classNames({\n      completed: todo.completed,\n      editing: isEditing\n    })}>\n      <div class=\"view\">\n        <input\n          class=\"toggle\"\n          type=\"checkbox\"\n          checked={todo.completed}\n          onchange={() => model.toggle(todo.id)}\n        />\n        <label ondblclick={handleStartEditing}>\n          {todo.title}\n        </label>\n        <button class=\"destroy\" onclick={() => model.removeTodo(todo.id)} />\n      </div>\n      <input\n        class=\"edit\"\n        value={editTodo}\n        onblur={handleSubmit}\n        oninput={handleChange}\n        onkeydown={handleKeyDown}\n      />\n    </li>\n  );\n};\n","let currentId = 0;\n\nexport default (todos, setTodos) => {\n  return {\n    addTodo(title) {\n      currentId++;\n\n      setTodos([].concat(todos, { id: currentId, title, completed: false }));\n    },\n\n    editTodo(id, newTitle) {\n      setTodos(todos.map(todo => todo.id === id ? { ...todo, title: newTitle } : todo));\n    },\n\n    removeTodo(id) {\n      setTodos(todos.filter(todo => todo.id !== id));\n    },\n\n    all() {\n      return [...todos];\n    },\n\n    toggleAll(checked = true) {\n      setTodos(todos.map(todo => ({ ...todo, completed: checked })));\n    },\n\n    toggle(id) {\n      setTodos(todos.map(todo => todo.id === id ? { ...todo, completed: !todo.completed } : todo));\n    },\n  };\n};\n","/** @jsx h */\nimport { VirtualDOM } from '../vdom';\n\nimport { App } from './components/app';\n\n/* const App = ({ time = new Date() }, { setState }) => {\n  window.setTimeout(() => setState('time', new Date()), 1000);\n\n  return (\n    <div>\n      <h1>The current time is:</h1>\n      {time.toLocaleTimeString('en-US')}\n    </div>\n  );\n  // const timeString = time.toLocaleTimeString('en-US');\n  // return h('div', {}, h('h1', {}, 'The current time is: '), h('span', {}, timeString));\n}; */\n\nnew VirtualDOM(App).renderInto(document.querySelector('.todoapp'));\n","import './tree/component';\nimport { createNode } from './nodes/factory';\nimport { TreeNode } from './nodes/treeNode';\nimport { applyContext } from './context/applyContext';\nimport { withStateReducer } from './context/reducerContext';\nimport { withCallback } from './context/callbackContext';\n\n/**\n * Constructor that enables the creation of a virtual DOM tree for the given component. This constructor can be called\n * multiple times on different components, there is no limit to the amount of virtual trees in a single page.\n *\n * @example\n * new VirtualDOM(App).renderInto(\"#app\");\n * @example\n * // You can also cache the tree for rendering in multiple locations\n * const app = new VirtualDOM(App);\n * app.renderInto(\"#app\");\n * app.renderInto(\"#other-app\");\n * @param root {TreeNode} - The component to render as the root of this tree.\n * @returns {{renderInto: renderInto}} Returns an object that can be chained to render this application into\n * multiple nodes.\n * @constructor\n * @export\n */\nexport function VirtualDOM(root) {\n  return {\n    /**\n     * Function that will render this application in the given HTMLElement.\n     * @param element {HTMLElement} - The element to use as the root of the application.\n     */\n    renderInto: element => {\n      if (typeof root !== 'function') {\n        throw new Error('The root of a virtual DOM tree must be a component');\n      }\n      const rootElement = document.createElement('vdom-component');\n      const virtualNode = new TreeNode({ factory: root, children: [], attributes: {} });\n      virtualNode.domNode = rootElement;\n      rootElement.setAll(root, {}, null, virtualNode);\n      element.appendChild(rootElement);\n    },\n  };\n}\n\nexport { createNode as h, applyContext, withStateReducer, withCallback };\n","/** @jsx h */\nimport { h } from '../../vdom';\n\nimport { Footer } from './footer';\nimport { TodoItem } from './todoItem';\nimport useTodoModel from '../model/todoModel';\n\nconst ALL_TODOS = 'all';\nconst ACTIVE_TODOS = 'active';\nconst COMPLETED_TODOS = 'completed';\n\nexport const App = (_, { todos = [], newTodo = '', nowShowing = ALL_TODOS, setState }) => {\n  const setNowShowing = val => setState('nowShowing', val);\n  const setNewTodo = val => setState('newTodo', val);\n  const setTodos = val => setState('todos', val);\n  const model = useTodoModel(todos, setTodos);\n\n  const handleChange = event => {\n    setNewTodo(event.target.value);\n  };\n\n  const handleNewTodoKeyDown = event => {\n    if (event.key !== 'Enter') {\n      return;\n    }\n\n    event.preventDefault();\n\n    const val = newTodo.trim();\n\n    if (val) {\n      model.addTodo(val);\n      setNewTodo('');\n    }\n  };\n\n  const allTodos = model.all();\n  const shownTodos = allTodos.filter(todo => {\n    switch (nowShowing) {\n      case ACTIVE_TODOS:\n        return !todo.completed;\n      case COMPLETED_TODOS:\n        return todo.completed;\n      default:\n        return true;\n    }\n  });\n\n  const activeTodoCount = allTodos.reduce((accum, todo) => todo.completed ? accum : accum + 1, 0);\n\n  const completedCount = allTodos.length - activeTodoCount;\n\n  return (\n    <div>\n      <header class=\"header\">\n        <h1>todos</h1>\n        <input\n          class=\"new-todo\"\n          placeholder=\"What needs to be done?\"\n          value={newTodo}\n          onkeydown={handleNewTodoKeyDown}\n          oninput={handleChange}\n          autoFocus={true}\n        />\n      </header>\n      {todos.length ? (\n        <section class=\"main\">\n          <input\n            id=\"toggle-all\"\n            class=\"toggle-all\"\n            type=\"checkbox\"\n            onchange={() => model.toggleAll(activeTodoCount !== 0)}\n            checked={activeTodoCount === 0}\n          />\n          <label\n            htmlFor=\"toggle-all\"\n          />\n          <ul class=\"todo-list\">\n            {shownTodos.map(todo => <TodoItem key={todo.id} todo={todo} model={model} />)}\n          </ul>\n        </section>\n      ) : null}\n      {(activeTodoCount || completedCount) ? (\n        <Footer\n          count={activeTodoCount}\n          completedCount={completedCount}\n          nowShowing={nowShowing}\n          setNowShowing={setNowShowing}\n          clearCompleted={() => model.toggleAll(false)}\n        />\n      ) : null}\n    </div>\n  );\n};\n"]}