{"mappings":"6nCAMaA,aAQX,SAAAA,EAAAC,GAA2C,IAA7BC,EAA6BD,EAA7BC,IAAKC,EAAwBF,EAAxBE,WAAYC,EAAYH,EAAZG,sGAAYC,CAAAC,KAAAN,GAKzCM,KAAKJ,IAAMA,EAMXI,KAAKH,WAAaA,EAMlBG,KAAKF,SAAWA,EAMhBE,KAAKC,QAAU,yDAQZC,GACH,OAAMA,aAAiBR,GAGnBM,KAAKJ,MAAQM,EAAMN,MAGnBO,OAAOC,QAAQJ,KAAKH,YAAYQ,MAAK,SAAAC,GAAA,IAAAC,EAAAC,EAAAF,EAAA,GAAEG,EAAFF,EAAA,GAAOG,EAAPH,EAAA,GAAA,OAAkBL,EAAML,WAAWY,KAASC,MAG9EV,KAAKF,SAASa,SAAWT,EAAMJ,SAASa,sNClDtCC,aAMX,SAAAA,EAAAjB,GAAsB,IAARkB,EAAQlB,EAARkB,kGAAQC,CAAAd,KAAAY,GAKpBZ,KAAKa,KAAOA,EAMZb,KAAKC,QAAU,yDAQZC,GACH,OAAMA,aAAiBU,GAGhBZ,KAAKa,OAASX,EAAMW,2pCC1BlBE,aAQX,SAAAA,EAAApB,GAA+C,IAAjCqB,EAAiCrB,EAAjCqB,QAASnB,EAAwBF,EAAxBE,WAAYC,EAAYH,EAAZG,sGAAYmB,CAAAjB,KAAAe,GAK7Cf,KAAKgB,QAAUA,EAMfhB,KAAKH,WAAaA,EAOlBG,KAAKF,SAAWA,EAMhBE,KAAKC,QAAU,yDAQZC,GACH,OAAMA,aAAiBa,IAGnBZ,OAAOC,QAAQJ,KAAKH,YAAYQ,MAAK,SAAAC,GAAA,IAAAC,EAAAW,EAAAZ,EAAA,GAAEG,EAAFF,EAAA,GAAOG,EAAPH,EAAA,GAAA,OAAkBL,EAAML,WAAWY,KAASC,MAG9EV,KAAKgB,UAAYd,EAAMc,k0CC1ClC,IAAMG,EAAkB,WAAkD,IAAjDC,EAAiDC,UAAAV,OAAA,QAAAW,IAAAD,UAAA,GAAAA,UAAA,GAAjC,GAAIE,EAA6BF,UAAAV,OAAA,QAAAW,IAAAD,UAAA,GAAAA,UAAA,GAAb,GAAIG,EAASH,UAAAV,OAAA,EAAAU,UAAA,QAAAC,EACxEnB,OAAOsB,KAAKL,GAAeM,SAAQ,SAAAjB,GAE5BN,OAAOwB,UAAUC,eAAeC,KAAKN,EAAed,IAASc,EAAcd,UAErD,IAAde,EAAKf,WAEPe,EAAKf,GAEde,EAAKM,gBAAgBrB,OAIzBN,OAAOC,QAAQmB,GAAeG,SAAQ,SAAA/B,GAAkB,IAAAW,EAAAyB,EAAApC,EAAA,GAAhBc,EAAgBH,EAAA,GAAXI,EAAWJ,EAAA,GACjC,mBAAVI,GAAwBP,OAAOwB,UAAUC,eAAeC,KAAKT,EAAeX,IACrFW,EAAcX,KAASC,SAIA,IAAdc,EAAKf,KAEde,EAAKf,GAAOC,GAEO,iBAAVA,GAAuC,iBAAVA,EAEtCc,EAAKQ,aAAavB,EAAKC,GACG,kBAAVA,IAEZA,EACFc,EAAKQ,aAAavB,EAAK,IAEvBe,EAAKM,gBAAgBrB,SAYvBwB,EAAe,SAAAC,GACnB,GAAIA,aAAWC,EACb,OAAOC,SAASC,cAAcH,EAAYtC,KACrC,GAAIsC,aAAWI,EACpB,OAAOF,SAASG,eAAeL,EAAYrB,MACtC,GAAIqB,aAAWM,EAAsB,CAC1C,IAAMC,EAAcL,SAASC,cAAc,kBAK3C,OAJAI,EAAYzB,QAAUkB,EAAYlB,QAClCyB,EAAYC,MAAQR,EAAYrC,WAChC4C,EAAYE,aAAeT,EAAYpC,SACvC2C,EAAYjB,KAAOU,EACZO,IAqCEG,EAAQ,SAACC,EAAQC,EAASC,GAErC,IAAKD,EAAS,CAEZ,IAAM7C,EAAUgC,EAAac,GAW7B,OAVAA,EAAQ9C,QAAUA,EACd8C,aAAOZ,GACThB,EAAgB,GAAI4B,EAAQlD,WAAYI,GAItC8C,EAAQjD,UACViD,EAAQjD,SAAS4B,SAAQ,SAAAsB,GAAK,OAAIJ,EAAMG,EAAS,KAAMC,WAEzDH,EAAO5C,QAAQgD,YAAYhD,GAK7B,GAAI6C,EAAQnB,YAAcoB,EAAQpB,UAAW,CAE3CkB,EAAO/C,SAAW+C,EAAO/C,SAASoD,KAAI,SAAAF,GACpC,OAAIA,IAAUF,EACLC,EAEFC,KAET,IAAM/C,EAAUgC,EAAac,GAC7BA,EAAQ9C,QAAUA,EACd8C,aAAOZ,GACThB,EAAgB2B,EAAQjD,WAAYkD,EAAQlD,WAAYI,GAEpD8C,aAAOP,GAGXI,EAAMC,EAAQ,KAAME,GAEtBF,EAAO5C,QAAQkD,aAAalD,EAAS6C,EAAQ7C,SAI/C,IAAK6C,EAAQM,KAAKL,KArED,SAACD,EAASC,GACvBD,aAAOX,GACThB,EAAgB2B,EAAQjD,WAAYkD,EAAQlD,WAAYiD,EAAQ7C,SAChE6C,EAAQjD,WAAakD,EAAQlD,YACpBiD,aAAOR,GAChBQ,EAAQjC,KAAOkC,EAAQlC,KACvBiC,EAAQ7C,QAAQoD,UAAYN,EAAQlC,MAC3BiC,aAAON,IAEhBM,EAAQjD,WAAakD,EAAQlD,WAC7BiD,EAAQhD,SAAWiD,EAAQjD,SAC3BgD,EAAQ9B,QAAU+B,EAAQ/B,QAE1B8B,EAAQ7C,QAAQe,QAAU+B,EAAQ/B,QAClC8B,EAAQ7C,QAAQyC,MAAQK,EAAQlD,WAChCiD,EAAQ7C,QAAQ0C,aAAeI,EAAQjD,UAwDvCwD,CAAWR,EAASC,GAChBD,aAAON,GAGTM,EAAQ7C,QAAQsD,aANpB,CAgBA,IAJA,IAAMC,EAAmBC,EAAKX,GAAWA,EAAQhD,SAAWgD,EAAQhD,SAAW,IAAK4D,UAC9EC,EAAmBF,EAAKV,GAAWA,EAAQjD,SAAWiD,EAAQjD,SAAW,IAAK4D,UAChFE,EAAQ,EAELJ,EAAiB7C,QAAQ,CAC9B,IAAMkD,EAAWL,EAAiBM,MAElC,IAAKH,EAAiBhD,OAAQ,CAE5BmC,EAAQhD,SAASiE,MAAMH,GAAOlC,SAAQ,SAAAsB,GACpCF,EAAQ7C,QAAQ+D,YAAYhB,EAAM/C,YAEpC6C,EAAQhD,SAAWgD,EAAQhD,SAASiE,MAAM,EAAGH,GAC7C,MAGFA,IACA,IAAMK,EAAWN,EAAiBG,MAGlClB,EAAME,EAASe,EAAUI,GAI3B,IA7EiD,IAAAC,EAAA,WA8E/C,IAAMD,EAAWN,EAAiBG,MAClChB,EAAQhD,SAASqE,KAAKF,GAGtB,IAAMhE,EAAUgC,EAAagC,GAC7BA,EAAShE,QAAUA,EACfgE,aAAQ9B,GACVhB,EAAgB,GAAI8C,EAASpE,WAAYI,GAIvCgE,EAASnE,UACXmE,EAASnE,SAAS4B,SAAQ,SAAAsB,GAAK,OAAIJ,EAAMqB,EAAU,KAAMjB,MAE3DF,EAAQ7C,QAAQgD,YAAYhD,IAfvB0D,EAAiBhD,QAAQuD,04DC1K5BE,oPAAyBC,OAAOC,8BAIpC,SAAAF,IAAc,IAAAG,EAAA,mGAAAC,CAAAxE,KAAAoE,IACZG,EAAAE,EAAA5C,KAAA7B,OAOK0E,SAAU,EAMfH,EAAK7B,MAAQ,GAMb6B,EAAK5B,aAAe,KAMpB4B,EAAKvD,QAAU,WAAA,OAAM,MAMrBuD,EAAKI,MAAQ,GAMbJ,EAAKK,KAAO,KAMZL,EAAK/C,KAAO,KA5CA+C,2DAoDZvE,KAAK6E,yCASEpE,EAAKC,GACZV,KAAK2E,MAAQxE,OAAO2E,OAAO,GAAI9E,KAAK2E,MAAvBI,EAAA,GAAiCtE,EAAMC,IAEhDV,KAAK0E,SACP1E,KAAKuD,0CAQP,IAAMyB,EAAQhF,KAAKiF,SACnBC,EAAMlF,KAAKwB,KAAMxB,KAAK4E,KAAMI,mCAQ5BhF,KAAK4E,KAAO5E,KAAKiF,SACjBjF,KAAK0E,SAAU,EACfQ,EAAMlF,KAAKwB,KAAM,KAAMxB,KAAK4E,uCAS5B,OAAO5E,KAAKgB,QAALmE,EAAAA,EAAA,GACFnF,KAAK0C,OADH,GAAA,CAEL5C,SAAUE,KAAK2C,eAFVwC,EAAAA,EAAA,GAGCnF,KAAK2E,OAHN,GAAA,CAGaS,SAAUpF,KAAKoF,SAASC,KAAKrF,wxBAIrDqE,OAAOiB,eAAeC,OAAO,iBAAkBnB,GC7GxC,IAAMoB,EAAU,SAAAC,GAKrB,IAHA,IAAMC,EAAKC,EAAOF,GACZG,EAAM,GAELF,EAAM/E,QAAQ,CAEnB,IAAMkF,EAAOH,EAAM5B,MACfgC,MAAMC,QAAQF,GAEhBH,EAAMvB,KAAN6B,MAAAN,EAAKC,EAASE,IACLA,MAAAA,GAETD,EAAIzB,KAAK0B,GAKb,OAAOD,EAAIlC,WCRb,IAAMuC,EAAkB,SAAAjD,GAAK,MACV,iBAAVA,GAAuC,iBAAVA,GAAuC,kBAAVA,EAC7DkD,EAAW,CAAErF,KAAMmC,GAAS,IAAMA,GAuB3BkD,EAAa,SAACtG,GAAsC,IAAA,IAAjCC,EAAiCwB,UAAAV,OAAA,QAAAW,IAAAD,UAAA,GAAAA,UAAA,GAApB,GAEvCqB,EAAQ7C,GAAc,GAFqCsG,EAAA9E,UAAAV,OAAbb,EAAa,IAAAgG,MAAAK,EAAA,EAAAA,EAAA,EAAA,GAAAC,EAAA,EAAAA,EAAAD,EAAAC,IAAbtG,EAAasG,EAAA,GAAA/E,UAAA+E,GAa/D,IAAMC,EAAeC,EAAQxG,GAC7B,MAAmB,mBAARF,EACF,IAAA4C,EAAa,CAClBxB,QAASpB,EACTC,WAAY6C,EACZ5C,SAAUuG,EAAanD,IAAI+C,KAG3B9F,OAAOwB,UAAUC,eAAeC,KAAKjC,EAAK,QACrC,IAAA0C,EAAa,CAAEzB,KAAMjB,EAAIiB,OAG3B,IAAAsB,EAAa,CAClBvC,IAAAA,EACAC,WAAY6C,EACZ5C,SAAUuG,EAAanD,IAAI+C,gBC9D9B,WAGA,IAAIM,EAAS,GAAG3E,eAEhB,SAAS4E,IAGR,IAFA,IAAIC,EAAU,GAELC,EAAI,EAAGA,EAAIrF,UAAUV,OAAQ+F,IAAK,CAC1C,IAAIC,EAAMtF,UAAUqF,GACpB,GAAKC,EAAL,CAEA,IAAIC,SAAiBD,EAErB,GAAgB,WAAZC,GAAoC,WAAZA,EAC3BH,EAAQtC,KAAKwC,QACP,GAAIb,MAAMC,QAAQY,IAAQA,EAAIhG,OAAQ,CAC5C,IAAIkG,EAAQL,EAAWR,MAAM,KAAMW,GAC/BE,GACHJ,EAAQtC,KAAK0C,QAER,GAAgB,WAAZD,EACV,IAAK,IAAInG,KAAOkG,EACXJ,EAAO1E,KAAK8E,EAAKlG,IAAQkG,EAAIlG,IAChCgG,EAAQtC,KAAK1D,IAMjB,OAAOgG,EAAQK,KAAK,KAGjBC,GACHP,EAAWQ,QAAUR,EACrBO,EAAiBP,GAOjBnC,OAAOmC,WAAaA,EA1CrB,GCHD,ICJgCS,KAAAA,MAClBA,EAAEC,WAAaD,EAAED,QAAUC,EDO5BE,EAAS,SAAAxH,GAA0E,IAAvEyH,EAAuEzH,EAAvEyH,MAAOC,EAAgE1H,EAAhE0H,eAAgBC,EAAgD3H,EAAhD2H,WAAYC,EAAoC5H,EAApC4H,cAAeC,EAAqB7H,EAArB6H,eACnEC,EAAiBL,EAAQ,EAAI,QAAU,OAEzCM,EAAc,KAWlB,OAVIL,EAAiB,IACnBK,EACEC,EAAA,SAAA,CACEC,MAAM,kBACNC,QAASL,GAFX,oBASFG,EAAA,SAAA,CAAQC,MAAM,UACZD,EAAA,OAAA,CAAMC,MAAM,cACVD,EAAA,SAAA,KAASP,GADX,IAC4BK,EAD5B,SAGAE,EAAA,KAAA,CAAIC,MAAM,WACRD,EAAA,KAAA,KACEA,EAAA,IAAA,CACEE,QAAS,WAAA,OAAMN,EA1BT,QA2BNK,MAAOE,EAAW,CAAEC,SA3Bd,QA2BwBT,KAFhC,QAMD,IACDK,EAAA,KAAA,KACEA,EAAA,IAAA,CACEE,QAAS,WAAA,OAAMN,EAjCN,WAkCTK,MAAOE,EAAW,CAAEC,SAlCX,WAkCqBT,KAFhC,WAMD,IACDK,EAAA,KAAA,KACEA,EAAA,IAAA,CACEE,QAAS,WAAA,OAAMN,EAxCH,cAyCZK,MAAOE,EAAW,CAAEC,SAzCR,cAyCkBT,KAFhC,eAOHI,IEhDMM,EAAW,SAAArI,EAAAW,GAAqE,IAAlE2H,EAAkEtI,EAAlEsI,KAAMC,EAA4DvI,EAA5DuI,MAA4DC,EAAA7H,EAAjD8H,UAAAA,OAAiD,IAAAD,GAAAA,EAAAE,EAAA/H,EAA9BgI,SAAAA,OAA8B,IAAAD,EAAnB,GAAmBA,EAAfjD,EAAe9E,EAAf8E,SACtEmD,EAAe,SAAAC,GAAG,OAAIpD,EAAS,YAAaoD,IAC5CC,EAAc,SAAAD,GAAG,OAAIpD,EAAS,WAAYoD,IAE1CE,EAAe,WACnB,IAAMF,EAAMF,EAASK,OAEjBH,IACFN,EAAMI,SAASL,EAAKW,GAAIJ,GACxBC,EAAY,IACZF,GAAa,KAiBjB,OACEZ,EAAA,KAAA,CAAIC,MAAOE,EAAW,CACpBe,UAAWZ,EAAKY,UAChBC,QAASV,KAETT,EAAA,MAAA,CAAKC,MAAM,QACTD,EAAA,QAAA,CACEC,MAAM,SACNmB,KAAK,WACLC,QAASf,EAAKY,UACdI,SAAU,WAAA,OAAMf,EAAMgB,OAAOjB,EAAKW,OAEpCjB,EAAA,QAAA,CAAOwB,cAAe,WAAA,OAAMZ,GAAa,KACtCN,EAAKmB,OAERzB,EAAA,SAAA,CAAQC,MAAM,UAAUC,QAAS,WAAA,OAAMK,EAAMmB,WAAWpB,EAAKW,QAE/DjB,EAAA,QAAA,CACEC,MAAM,OACNlH,MAAO4H,EACPgB,OAAQZ,EACRa,QAlCe,SAAAC,GACnBf,EAAYe,EAAMC,OAAO/I,QAkCrBgJ,UA/BgB,SAAAF,GACF,UAAdA,EAAM/I,MAIV+I,EAAMG,iBACNjB,26CC5BJ,IAAIkB,EAAY,ECkBhB,ICGO,SAAoBC,GACzB,MAAO,CAKLC,WAAY,SAAAC,GACV,GAAoB,mBAATF,EACT,MAAM,IAAIG,MAAM,sDAElB,IAAMvH,EAAcL,SAASC,cAAc,kBAC3CI,EAAYzB,QAAU6I,EACtBpH,EAAYjB,KAAO,IAAAgB,EAAa,CAAExB,QAAS6I,EAAM/J,SAAU,GAAID,WAAY,KAC3E4C,EAAYjB,KAAKvB,QAAUwC,EAC3BsH,EAAQ9G,YAAYR,KDjB1B,EEPmB,SAACwH,EAADtK,GAAuE,IAAAuK,EAAAvK,EAAjEwK,MAAAA,OAAiE,IAAAD,EAAzD,GAAyDA,EAAAE,EAAAzK,EAArD0K,QAAAA,OAAqD,IAAAD,EAA3C,GAA2CA,EAAAE,EAAA3K,EAAvC2H,WAAAA,OAAuC,IAAAgD,EAJxE,MAIwEA,EAAflF,EAAezF,EAAfyF,SAEnEmF,EAAa,SAAA/B,GAAG,OAAIpD,EAAS,UAAWoD,IAExCN,EHbO,SAACiC,EAAOK,GACrB,MAAO,CACLC,QADK,SACGrB,GACNQ,IAEAY,EAAS,GAAGE,OAAOP,EAAO,CAAEvB,GAAIgB,EAAWR,MAAAA,EAAOP,WAAW,MAG/DP,SAPK,SAOIM,EAAI+B,GACXH,EAASL,EAAMjH,KAAI,SAAA+E,GAAI,OAAIA,EAAKW,KAAOA,EAAZgC,EAAAA,EAAA,GAAsB3C,GAAtB,GAAA,CAA4BmB,MAAOuB,IAAa1C,OAG7EoB,WAXK,SAWMT,GACT4B,EAASL,EAAMU,QAAO,SAAA5C,GAAI,OAAIA,EAAKW,KAAOA,OAG5CkC,IAfK,WAgBH,OAAAC,EAAWZ,IAGba,UAnBK,WAmBqB,IAAhBhC,IAAgB3H,UAAAV,OAAA,QAAAW,IAAAD,UAAA,KAAAA,UAAA,GACxBmJ,EAASL,EAAMjH,KAAI,SAAA+E,GAAI,OAAA2C,EAAAA,EAAA,GAAU3C,GAAV,GAAA,CAAgBY,UAAWG,SAGpDE,OAvBK,SAuBEN,GACL4B,EAASL,EAAMjH,KAAI,SAAA+E,GAAI,OAAIA,EAAKW,KAAOA,EAAZgC,EAAAA,EAAA,GAAsB3C,GAAtB,GAAA,CAA4BY,WAAYZ,EAAKY,YAAcZ,QGZ5EgD,CAAad,GADV,SAAA3B,GAAG,OAAIpD,EAAS,QAASoD,MAsBpC0C,EAAWhD,EAAM4C,MACjBK,EAAaD,EAASL,QAAO,SAAA5C,GACjC,OAAQX,GACN,IA/Be,SAgCb,OAAQW,EAAKY,UACf,IAhCkB,YAiChB,OAAOZ,EAAKY,UACd,QACE,OAAO,MAIPuC,EAAkBF,EAASG,QAAO,SAACC,EAAOrD,GAAR,OAAiBA,EAAKY,UAAYyC,EAAQA,EAAQ,IAAG,GAEvFjE,EAAiB6D,EAASvK,OAASyK,EAEzC,OACEzD,EAAA,MAAA,KACEA,EAAA,SAAA,CAAQC,MAAM,UACZD,EAAA,KAAA,KAAA,SACAA,EAAA,QAAA,CACEC,MAAM,WACN2D,YAAY,yBACZ7K,MAAO2J,EACPX,UAvCqB,SAAAF,GAC3B,GAAkB,UAAdA,EAAM/I,IAAV,CAIA+I,EAAMG,iBAEN,IAAMnB,EAAM6B,EAAQ1B,OAEhBH,IACFN,EAAMuC,QAAQjC,GACd+B,EAAW,OA6BPhB,QA5Ca,SAAAC,GACnBe,EAAWf,EAAMC,OAAO/I,QA4ClB8K,WAAW,KAGdrB,EAAMxJ,OACLgH,EAAA,UAAA,CAASC,MAAM,QACbD,EAAA,QAAA,CACEiB,GAAG,aACHhB,MAAM,aACNmB,KAAK,WACLE,SAAU,WAAA,OAAMf,EAAM8C,UAA8B,IAApBI,IAChCpC,QAA6B,IAApBoC,IAEXzD,EAAA,QAAA,CACE8D,QAAQ,eAEV9D,EAAA,KAAA,CAAIC,MAAM,aACPuD,EAAWjI,KAAI,SAAA+E,GAAI,OAAIN,EAAA+D,EAAA,CAAUjL,IAAKwH,EAAKW,GAAIX,KAAMA,EAAMC,MAAOA,SAGrE,KACFkD,GAAmB/D,EACnBM,EAAAgE,EAAA,CACEvE,MAAOgE,EACP/D,eAAgBA,EAChBC,WAAYA,EACZC,cA3Ec,SAAAiB,GAAG,OAAIpD,EAAS,aAAcoD,IA4E5ChB,eAAgB,WAAA,OAAMU,EAAM8C,WAAU,MAEtC,SFxEUlB,WAAW1H,SAASwJ,cAAc","sources":["src/project/vdom/nodes/htmlNode.js","src/project/vdom/nodes/textNode.js","src/project/vdom/nodes/treeNode.js","src/project/vdom/diffing/patchTree.js","src/project/vdom/tree/component.js","src/project/vdom/utils/flattenArray.js","src/project/vdom/nodes/factory.js","node_modules/classnames/index.js","src/project/demo/components/footer.jsx","/home/runner/work/carleton-web-dev/carleton-web-dev/node_modules/@parcel/scope-hoisting/lib/helpers.js","src/project/demo/components/todoItem.jsx","src/project/demo/model/todoModel.js","src/project/demo/index.jsx","src/project/vdom/index.js","src/project/demo/components/app.jsx"],"names":["HtmlNode","_ref","tag","attributes","children","$c483bf5af8290f2cd662c50f1336bd$var$_classCallCheck","this","domNode","other","Object","entries","find","_ref2","_ref3","$c483bf5af8290f2cd662c50f1336bd$var$_slicedToArray","key","value","length","TextNode","text","$ab51a5e78fa39f5c0b7d5925fb737f05$var$_classCallCheck","TreeNode","factory","$a34c81a8396481576d56101484e55d4$var$_classCallCheck","$a34c81a8396481576d56101484e55d4$var$_slicedToArray","applyAttributes","oldAttributes","arguments","undefined","newAttributes","node","keys","forEach","prototype","hasOwnProperty","call","removeAttribute","$f6663bccd22350ea64877355572b61e2$var$_slicedToArray","setAttribute","generateNode","virtualNode","$c483bf5af8290f2cd662c50f1336bd$export$HtmlNode","document","createElement","$ab51a5e78fa39f5c0b7d5925fb737f05$export$TextNode","createTextNode","$a34c81a8396481576d56101484e55d4$export$TreeNode","rootElement","props","virtualChild","patch","parent","oldNode","newNode","child","appendChild","map","replaceChild","diff","nodeValue","updateNode","update","oldChildrenQueue","$f6663bccd22350ea64877355572b61e2$var$_toConsumableArray","reverse","newChildrenQueue","index","oldChild","pop","slice","removeChild","newChild","_loop","push","ComponentElement","window","HTMLElement","_this","$bd7c0fa29be02bde8091569334a2372a$var$_classCallCheck","_super","mounted","state","tree","mount","assign","$bd7c0fa29be02bde8091569334a2372a$var$_defineProperty","vtree","render","$f6663bccd22350ea64877355572b61e2$export$patch","$bd7c0fa29be02bde8091569334a2372a$var$_objectSpread","setState","bind","customElements","define","flatten","input","stack","$b4004002b7d326e5c6469a6a5b468$var$_toConsumableArray","res","next","Array","isArray","apply","vdonizeChildren","createNode","_len","_key","flatChildren","$b4004002b7d326e5c6469a6a5b468$export$flatten","hasOwn","classNames","classes","i","arg","argType","inner","join","$dc5118610df5cc910ea040e1de8e$exports","default","a","__esModule","Footer","count","completedCount","nowShowing","setNowShowing","clearCompleted","activeTodoWord","clearButton","$efe9a6cdc457f0954e90dd2137a671e0$export$createNode","class","onclick","$dc5118610df5cc910ea040e1de8e$$interop$default","selected","TodoItem","todo","model","_ref2$isEditing","isEditing","_ref2$editTodo","editTodo","setIsEditing","val","setEditTodo","handleSubmit","trim","id","completed","editing","type","checked","onchange","toggle","ondoubleclick","title","removeTodo","onblur","oninput","event","target","onkeydown","preventDefault","currentId","root","renderInto","element","Error","_","_ref$todos","todos","_ref$newTodo","newTodo","_ref$nowShowing","setNewTodo","setTodos","addTodo","concat","newTitle","$b9d57fa8a5c1de4aab41f5e867bd$var$_objectSpread","filter","all","$b9d57fa8a5c1de4aab41f5e867bd$var$_toConsumableArray","toggleAll","$b9d57fa8a5c1de4aab41f5e867bd$export$default","allTodos","shownTodos","activeTodoCount","reduce","accum","placeholder","autoFocus","htmlFor","$a4640d8033a36054353575a1596c$export$TodoItem","$aaa9c2a41b10e743c5ff0e575e69d19$export$Footer","querySelector"],"version":3,"file":"demo.7aff562c.js.map","sourcesContent":["/**\n * HTML node class that manages an HTML element in the virtual Tree.\n * @todo Support SVGs\n * @export\n * @class HtmlNode\n */\nexport class HtmlNode {\n  /**\n   * Class constructor that stores the values.\n   * @param {Object} props - The properties given to this constructor.\n   * @param {String} props.tag - Tag name to create in the DOM when this node is mounted.\n   * @param {object} props.attributes - Attributes to assign to the HTML node when created.\n   * @param {(TreeNode|HtmlNode|TextNode)[]} props.children - The children to assign to the HTML node when created.\n   */\n  constructor({ tag, attributes, children }) {\n    /**\n     * Tag for creating the HTMLElement in the DOM when mounting.\n     * @type {String}\n     */\n    this.tag = tag;\n\n    /**\n     * Attributes to assign to the HTMLElement when mounting or updating.\n     * @type {Object}\n     */\n    this.attributes = attributes;\n\n    /**\n     * Virtual children that will have to be patched into the virtual DOM node when mounting or updating.\n     * @type {(TreeNode|HtmlNode|TextNode)[]}\n     */\n    this.children = children;\n\n    /**\n     * DOM node assigned to this virtual node for easy access.\n     * @type {HTMLElement}\n     */\n    this.domNode = null;\n  }\n\n  /**\n   * Diffing function that returns if the two nodes are the same or not.\n   * @param other {TreeNode|HtmlNode|TextNode}\n   * @returns {boolean} Returns true if the two nodes are the same, false otherwise.\n   */\n  diff(other) {\n    if (!(other instanceof HtmlNode)) {\n      return false;\n    }\n    if (this.tag !== other.tag) {\n      return false;\n    }\n    if (Object.entries(this.attributes).find(([key, value]) => other.attributes[key] !== value)) {\n      return false;\n    }\n    return this.children.length === other.children.length;\n  }\n}\n","/**\n * Text node class that manages a text element in the virtual Tree.\n * @export\n * @class TextNode\n */\nexport class TextNode {\n  /**\n   * Class constructor that stores the values.\n   * @param {Object} props - The properties given to this constructor.\n   * @param {String} props.text - Text to display through this virtual node.\n   */\n  constructor({ text }) {\n    /**\n     * Stores the text to display in the DOM when mounted or updated.\n     * @type {String}\n     */\n    this.text = text;\n\n    /**\n     * DOM node assigned to this virtual node for easy access.\n     * @type {Text}\n     */\n    this.domNode = null;\n  }\n\n  /**\n   * Diffing function that returns if the two nodes are the same or not.\n   * @param other {TreeNode|HtmlNode|TextNode}\n   * @returns {boolean} Returns true if the two nodes are the same, false otherwise.\n   */\n  diff(other) {\n    if (!(other instanceof TextNode)) {\n      return false;\n    }\n    return this.text === other.text;\n  }\n}\n","import '../utils/typeDef';\n\n/**\n * Tree node class that manages component based classes. When the node creator hits a function, it will\n * create an instance of this class.\n * @export\n * @class TreeNode\n */\nexport class TreeNode {\n  /**\n   * Class constructor that stores the values.\n   * @param {Object} props - The properties given to this constructor.\n   * @param {functionComponent} props.factory - Component to build when this node is rendered in the view.\n   * @param {object} props.attributes - Attributes to pass to the factory when called.\n   * @param {(TreeNode|HtmlNode|TextNode)[]} props.children - The children to pass to the factory when called.\n   */\n  constructor({ factory, attributes, children }) {\n    /**\n     * Stores the factory used to render this component.\n     * @type {functionComponent}\n     */\n    this.factory = factory;\n\n    /**\n     * The attributes assigned to this node, will be passed to the factory when it is executed.\n     * @type {Object}\n     */\n    this.attributes = attributes;\n\n    /**\n     * Children of the node. Will be passed tot he factory when it is execute. Not to confuse with the children\n     * rendered by the factory.\n     * @type {(TreeNode|HtmlNode|TextNode)[]}\n     */\n    this.children = children;\n\n    /**\n     * DOM node assigned to this virtual node for easy access.\n     * @type {HTMLElement}\n     */\n    this.domNode = null;\n  }\n\n  /**\n   * Diffing function that returns if the two nodes are the same or not.\n   * @param other {TreeNode|HtmlNode|TextNode}\n   * @returns {boolean} Returns true if the two nodes are the same, false otherwise.\n   */\n  diff(other) {\n    if (!(other instanceof TreeNode)) {\n      return false;\n    }\n    if (Object.entries(this.attributes).find(([key, value]) => other.attributes[key] !== value)) {\n      return false;\n    }\n    return this.factory === other.factory;\n  }\n}\n","import { HtmlNode } from '../nodes/htmlNode';\nimport { TextNode } from '../nodes/textNode';\nimport { TreeNode } from '../nodes/treeNode';\n\n/**\n * Function that will apply the given attributes on the HTML element. The old attributes are passed for removing\n * attributes when needed. For example, if an attribute is present in the old attributes, but not in the new\n * attributes, it should be removed from the DOM node.\n * @todo support namespaced attributes\n * @param {Object} oldAttributes - The old attributes that were assigned to the node before the patch.\n * @param {Object} newAttributes - The new attributes that were assigned to the node after the patch.\n * @param {HTMLElement} node - The node on which to apply the attribute changes.\n */\nconst applyAttributes = (oldAttributes = {}, newAttributes = {}, node) => {\n  Object.keys(oldAttributes).forEach(key => {\n    // If the new attributes doesn't have the old attribute\n    if (!Object.prototype.hasOwnProperty.call(newAttributes, key) || !newAttributes[key]) {\n      // Remove the attribute from the node since it is now gone\n      if (typeof node[key] !== 'undefined') {\n        // Delete on the node directly if we can\n        delete node[key];\n      }\n      node.removeAttribute(key);\n    }\n  });\n  // Go over the new attributes\n  Object.entries(newAttributes).forEach(([key, value]) => {\n    if (typeof value !== 'function' && Object.prototype.hasOwnProperty.call(oldAttributes, key) &&\n      oldAttributes[key] === value) {\n      // If the attribute did not change and is not an event listener, don't bother updating\n      return;\n    }\n    if (typeof node[key] !== 'undefined') {\n      // Set on the node directly if we can\n      node[key] = value;\n    }\n    if (typeof value === 'string' || typeof value === 'number') {\n      // Set the new attribute value on the node\n      node.setAttribute(key, value);\n    } else if (typeof value === 'boolean') {\n      // For booleans, set the attribute as an empty string if true or remove if false\n      if (value) {\n        node.setAttribute(key, '');\n      } else {\n        node.removeAttribute(key);\n      }\n    }\n  });\n};\n\n/**\n * Generate a DOM node with the given virtual node. If generating a virtual dom component, it will also assign\n * all the properties on the web component.\n * @param {HtmlNode|TextNode|TreeNode} virtualNode - The node from which to create the DOM node.\n * @returns {Node} - Returns a DOM node that can be used directly.\n */\nconst generateNode = virtualNode => {\n  if (virtualNode instanceof HtmlNode) {\n    return document.createElement(virtualNode.tag);\n  } else if (virtualNode instanceof TextNode) {\n    return document.createTextNode(virtualNode.text);\n  } else if (virtualNode instanceof TreeNode) {\n    const rootElement = document.createElement('vdom-component');\n    rootElement.factory = virtualNode.factory;\n    rootElement.props = virtualNode.attributes;\n    rootElement.virtualChild = virtualNode.children;\n    rootElement.node = virtualNode;\n    return rootElement;\n  }\n};\n\n/**\n * Updates a virtual node and its associated DOM node with the values of the new virtual node.\n * @param {HtmlNode|TextNode|TreeNode} oldNode - The node to update.\n * @param {HtmlNode|TextNode|TreeNode} newNode - The node to update from.\n */\nconst updateNode = (oldNode, newNode) => {\n  if (oldNode instanceof HtmlNode) {\n    applyAttributes(oldNode.attributes, newNode.attributes, oldNode.domNode);\n    oldNode.attributes = newNode.attributes;\n  } else if (oldNode instanceof TextNode) {\n    oldNode.text = newNode.text;\n    oldNode.domNode.nodeValue = newNode.text;\n  } else if (oldNode instanceof TreeNode) {\n    // Update the virtual attributes for a component node\n    oldNode.attributes = newNode.attributes;\n    oldNode.children = newNode.children;\n    oldNode.factory = newNode.factory;\n    // Update the DOM attributes from the associated web component\n    oldNode.domNode.factory = newNode.factory;\n    oldNode.domNode.props = newNode.attributes;\n    oldNode.domNode.virtualChild = newNode.children;\n  }\n};\n\n/**\n * Main diffing algorithm that will diff nodes and patch them in place, generating DOM mutations alongside virtual DOM\n * mutations. Will be recursively called on all the nodes in the tree until the entire tree has been patched.\n * @param {HtmlNode|TextNode|TreeNode} parent - The parent of the old and new node. Used to add or remove children.\n * @param {HtmlNode|TextNode|TreeNode} oldNode - The node from the tree that is being patched. Is modified by the\n * algorithm.\n * @param {HtmlNode|TextNode|TreeNode} newNode - The node from the new tree used to patch the old tree.\n * @export\n */\nexport const patch = (parent, oldNode, newNode) => {\n  // If Old node does not exists, then we are mounting for the first time\n  if (!oldNode) {\n    // Generate the dom node\n    const domNode = generateNode(newNode);\n    newNode.domNode = domNode;\n    if (newNode instanceof HtmlNode) {\n      applyAttributes({}, newNode.attributes, domNode);\n    }\n\n    // Start patching on the new node's children\n    if (newNode.children) {\n      newNode.children.forEach(child => patch(newNode, null, child));\n    }\n    parent.domNode.appendChild(domNode);\n    return;\n  }\n\n  // If the two nodes don't have the same type\n  if (oldNode.prototype !== newNode.prototype) {\n    // Replace the old child with the new child\n    parent.children = parent.children.map(child => {\n      if (child === oldNode) {\n        return newNode;\n      }\n      return child;\n    });\n    const domNode = generateNode(newNode);\n    newNode.domNode = domNode;\n    if (newNode instanceof HtmlNode) {\n      applyAttributes(oldNode.attributes, newNode.attributes, domNode);\n    }\n    if (!(newNode instanceof TreeNode)) {\n      // Start patching the new node if they are not components\n      // If they are components, the connectedCallback function will take care of the rest\n      patch(parent, null, newNode);\n    }\n    parent.domNode.replaceChild(domNode, oldNode.domNode);\n  }\n\n  // If the nodes are different, but of the same type\n  if (!oldNode.diff(newNode)) {\n    // Update the nodes\n    updateNode(oldNode, newNode);\n    if (oldNode instanceof TreeNode) {\n      // If this node is a component, stop right here and update the component.\n      // The component will take care of patching the children\n      oldNode.domNode.update();\n      return;\n    }\n  }\n\n  // Proceed to update the children or replace them if needed\n  const oldChildrenQueue = [...(oldNode && oldNode.children ? oldNode.children : [])].reverse();\n  const newChildrenQueue = [...(newNode && newNode.children ? newNode.children : [])].reverse();\n  let index = 0;\n  // Loop in the old children until we have no more children\n  while (oldChildrenQueue.length) {\n    const oldChild = oldChildrenQueue.pop();\n    // If there are no more new children\n    if (!newChildrenQueue.length) {\n      // We have to remove the remaining old children and break the loop\n      oldNode.children.slice(index).forEach(child => {\n        oldNode.domNode.removeChild(child.domNode);\n      });\n      oldNode.children = oldNode.children.slice(0, index);\n      break;\n    }\n\n    index++;\n    const newChild = newChildrenQueue.pop();\n\n    // Start patching the two nodes\n    patch(oldNode, oldChild, newChild);\n  }\n\n  // Loop in the new children if there are more\n  while (newChildrenQueue.length) {\n    const newChild = newChildrenQueue.pop();\n    oldNode.children.push(newChild);\n\n    // Generate the new node and append it to the dom\n    const domNode = generateNode(newChild);\n    newChild.domNode = domNode;\n    if (newChild instanceof HtmlNode) {\n      applyAttributes({}, newChild.attributes, domNode);\n    }\n\n    // Start patching the new node's children\n    if (newChild.children) {\n      newChild.children.forEach(child => patch(newChild, null, child));\n    }\n    oldNode.domNode.appendChild(domNode);\n  }\n};\n","import { patch } from '../diffing/patchTree';\nimport '../utils/typeDef';\n\n/**\n * Custom element that allows us to manage components as trees rather than nodes of a tree. These components\n * are stored inside of the actual DOM and keep their own virtual tree. When one is added to the DOM structure,\n * it will render the function stored in factory and mount the virtual nodes into the DOM.\n * @export\n * @class ComponentElement\n * @extends window.HTMLElement\n */\nclass ComponentElement extends window.HTMLElement {\n  /**\n   * Class constructor.\n   */\n  constructor() {\n    super();\n\n    /**\n     * Stores whether or not the component has mounted the content of its factory. Will not update\n     * if it has yet to be mounted.\n     * @type {boolean}\n     */\n    this.mounted = false;\n\n    /**\n     * Stores the properties of the component given as attributes when the `createNode` function is called.\n     * @type {{}}\n     */\n    this.props = {};\n\n    /**\n     * Stores the virtual children that are to be passed to the factory when rendering.\n     * @type {TreeNode|TextNode|HtmlNode}\n     */\n    this.virtualChild = null;\n\n    /**\n     * The factory to execute when this component mounts or update.\n     * @type {functionComponent}\n     */\n    this.factory = () => null;\n\n    /**\n     * Object that stores the component's state. Updated with the `setState` method of this class.\n     * @type {{}}\n     */\n    this.state = {};\n\n    /**\n     * The tree mounted on this component. When the component updates, this tree is updated in place.\n     * @type {TreeNode|TextNode|HtmlNode}\n     */\n    this.tree = null;\n\n    /**\n     * The TreeNode instance for this component to make sure the two can properly communicate.\n     * @type {TreeNode}\n     */\n    this.node = null;\n  }\n\n  /**\n   * The lifecycle method called by the DOM. Will use the fact that the node has been added to the DOM to\n   * mount the content of the factory.\n   */\n  connectedCallback() {\n    this.mount();\n  }\n\n  /**\n   * The setState method that is passed to the factory for setting the state values stored on this component. If the\n   * component has mounted its tree, it will also trigger an update.\n   * @param key {String} - The name of the state value to update or set.\n   * @param value {any} - The value to assign to the part of the state to update.\n   */\n  setState(key, value) {\n    this.state = Object.assign({}, this.state, { [key]: value });\n    // Only update the view if the component has been mounted.\n    if (this.mounted) {\n      this.update();\n    }\n  }\n\n  /**\n   * Update method that will trigger a new render of this virtual tree and execute the diffing algorithm.\n   */\n  update() {\n    const vtree = this.render();\n    patch(this.node, this.tree, vtree);\n  }\n\n  /**\n   * Mount method that is triggered when the component is mounted to the DOM. Will render the tree for the first time\n   * and diff it against the empty DOM.\n   */\n  mount() {\n    this.tree = this.render();\n    this.mounted = true;\n    patch(this.node, null, this.tree);\n  }\n\n  /**\n   * Render method used to render the factory using the component's state and properties.\n   * @private\n   * @returns {TreeNode|TextNode|HtmlNode} Returns the rendered factory.\n   */\n  render() {\n    return this.factory({\n      ...this.props,\n      children: this.virtualChild,\n    }, { ...this.state, setState: this.setState.bind(this) });\n  }\n}\n\nwindow.customElements.define('vdom-component', ComponentElement);\n","/**\n * Utility method that will flatten an array with infinite depth down to a single continuous array.\n * This method will remove any null or empty elements without modifying the original array.\n * @param input {Array} - The input array to flatten.\n * @returns {*[]} The flattened array without any nulls or undefined.\n */\nexport const flatten = input => {\n  // Create a stack with all the inputs\n  const stack = [...input];\n  const res = [];\n  // While there are elements in the stack\n  while (stack.length) {\n    // Pop value from stack\n    const next = stack.pop();\n    if (Array.isArray(next)) {\n      // Push back array items without modifying the original input\n      stack.push(...next);\n    } else if (next !== null && typeof next !== 'undefined') {\n      // If the next element is not an array, make sure it is not null or undefined.\n      res.push(next);\n    }\n  }\n\n  // Reverse to restore input order, adding at the end of an array is far more performant than adding at the beginning.\n  return res.reverse();\n};\n","import { TreeNode } from './treeNode';\nimport { TextNode } from './textNode';\nimport { HtmlNode } from './htmlNode';\nimport { flatten } from '../utils/flattenArray';\n\n/**\n * Transform all children that are not object readable bu the `createNode` function into an object\n * that can ve processed by that same function. In particular, it makes sure that you can pass a string as\n * a children and still get a valid node.\n *\n * This enables something like:\n * @example\n *   createNode(\"span\", {}, \"Hello, world!\");\n * @param child {*} - The children the manage. This function is intended to be called within a `.map` call.\n * @returns {TreeNode|TextNode|HtmlNode|*} Returns a valid virtual node.\n */\nconst vdonizeChildren = child =>\n  typeof child === 'string' || typeof child === 'number' || typeof child === 'boolean'\n    ? createNode({ text: child }, {}) : child;\n\n/**\n * This factory method takes JSX compliant parameters and generate small objects that represent our\n * virtual nodes. By walking this tree of nodes, we can process the virtual DOM tree and mount in on the DOM.\n *\n * If given a string as the tag, it will render an HTML node. Text nodes are managed through the `vdonizeChildren`\n * method, meaning that your only way to create text nodes is by giving a text children to another node. It also means\n * that the root node of an application cannot be a text node.\n *\n * If given a function as the tag, the creator will return a TreeNode to generate a new subtree and\n * execute the component.\n *\n * @example\n * createNode(({ text }) => createNode(\"h1\", { style: \"color: red;\" }, text), { text: \"Hello, World!\" });\n * @param tag {String|Function|{ text: String }} - The tag of this virtual node.\n * @param attributes {Object} - The attributes of the node if it needs any. Only components and HTML nodes use\n * attributes.\n * @param children {TreeNode|TextNode|HtmlNode|String} - the children to pass to the virtual node if it needs any.\n * Text nodes will ignore the children parameter if they are given some.\n * @returns {TreeNode|TextNode|HtmlNode} Returns a valid virtual node.\n * @export\n */\nexport const createNode = (tag, attributes = {}, ...children) => {\n  // protect against null attributes\n  let props = attributes || {};\n\n  // Remove attributes added by JSX in development\n  if (process.env.NODE_ENV === 'development') {\n    // eslint-disable-next-line no-unused-vars\n    const { __self, __source, ...rest } = props;\n    props = rest;\n  }\n\n  // Flatten the children so that any array created with things like .map are processed as a single continuous array.\n  // TODO: This might be inefficient long term.\n  const flatChildren = flatten(children);\n  if (typeof tag === 'function') {\n    return new TreeNode({\n      factory: tag,\n      attributes: props,\n      children: flatChildren.map(vdonizeChildren),\n    });\n  }\n  if (Object.prototype.hasOwnProperty.call(tag, 'text')) {\n    return new TextNode({ text: tag.text });\n  }\n\n  return new HtmlNode({\n    tag,\n    attributes: props,\n    children: flatChildren.map(vdonizeChildren),\n  });\n};\n","/*!\n  Copyright (c) 2017 Jed Watson.\n  Licensed under the MIT License (MIT), see\n  http://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\n\tfunction classNames () {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg) && arg.length) {\n\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\tif (inner) {\n\t\t\t\t\tclasses.push(inner);\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","/** @jsx h */\nimport { h } from '../../vdom';\nimport classNames from 'classnames';\n\nconst ALL_TODOS = 'all';\nconst ACTIVE_TODOS = 'active';\nconst COMPLETED_TODOS = 'completed';\n\nexport const Footer = ({ count, completedCount, nowShowing, setNowShowing, clearCompleted }) => {\n  const activeTodoWord = count > 1 ? 'items' : 'item';\n\n  let clearButton = null;\n  if (completedCount > 0) {\n    clearButton = (\n      <button\n        class=\"clear-completed\"\n        onclick={clearCompleted}>\n        Clear completed\n      </button>\n    );\n  }\n\n  return (\n    <footer class=\"footer\">\n      <span class=\"todo-count\">\n        <strong>{count}</strong> {activeTodoWord} left\n      </span>\n      <ul class=\"filters\">\n        <li>\n          <a\n            onclick={() => setNowShowing(ALL_TODOS)}\n            class={classNames({ selected: nowShowing === ALL_TODOS })}>\n            All\n          </a>\n        </li>\n        {' '}\n        <li>\n          <a\n            onclick={() => setNowShowing(ACTIVE_TODOS)}\n            class={classNames({ selected: nowShowing === ACTIVE_TODOS })}>\n            Active\n          </a>\n        </li>\n        {' '}\n        <li>\n          <a\n            onclick={() => setNowShowing(COMPLETED_TODOS)}\n            class={classNames({ selected: nowShowing === COMPLETED_TODOS })}>\n            Completed\n          </a>\n        </li>\n      </ul>\n      {clearButton}\n    </footer>\n  );\n};\n",null,"/** @jsx h */\nimport { h } from '../../vdom';\nimport classNames from 'classnames';\n\nexport const TodoItem = ({ todo, model }, { isEditing = false, editTodo = '', setState }) => {\n  const setIsEditing = val => setState('isEditing', val);\n  const setEditTodo = val => setState('editTodo', val);\n\n  const handleSubmit = () => {\n    const val = editTodo.trim();\n\n    if (val) {\n      model.editTodo(todo.id, val);\n      setEditTodo('');\n      setIsEditing(false);\n    }\n  };\n\n  const handleChange = event => {\n    setEditTodo(event.target.value);\n  };\n\n  const handleKeyDown = event => {\n    if (event.key !== 'Enter') {\n      return;\n    }\n\n    event.preventDefault();\n    handleSubmit();\n  };\n\n  return (\n    <li class={classNames({\n      completed: todo.completed,\n      editing: isEditing\n    })}>\n      <div class=\"view\">\n        <input\n          class=\"toggle\"\n          type=\"checkbox\"\n          checked={todo.completed}\n          onchange={() => model.toggle(todo.id)}\n        />\n        <label ondoubleclick={() => setIsEditing(true)}>\n          {todo.title}\n        </label>\n        <button class=\"destroy\" onclick={() => model.removeTodo(todo.id)} />\n      </div>\n      <input\n        class=\"edit\"\n        value={editTodo}\n        onblur={handleSubmit}\n        oninput={handleChange}\n        onkeydown={handleKeyDown}\n      />\n    </li>\n  );\n};\n","let currentId = 0;\n\nexport default (todos, setTodos) => {\n  return {\n    addTodo(title) {\n      currentId++;\n\n      setTodos([].concat(todos, { id: currentId, title, completed: false }));\n    },\n\n    editTodo(id, newTitle) {\n      setTodos(todos.map(todo => todo.id === id ? { ...todo, title: newTitle } : todo));\n    },\n\n    removeTodo(id) {\n      setTodos(todos.filter(todo => todo.id !== id));\n    },\n\n    all() {\n      return [...todos];\n    },\n\n    toggleAll(checked = true) {\n      setTodos(todos.map(todo => ({ ...todo, completed: checked })));\n    },\n\n    toggle(id) {\n      setTodos(todos.map(todo => todo.id === id ? { ...todo, completed: !todo.completed } : todo));\n    },\n  };\n};\n","/** @jsx h */\nimport { VirtualDOM } from '../vdom';\n\nimport { App } from './components/app';\n\n/* const App = ({ time = new Date() }, { setState }) => {\n  window.setTimeout(() => setState('time', new Date()), 1000);\n\n  return (\n    <div>\n      <h1>The current time is:</h1>\n      {time.toLocaleTimeString('en-US')}\n    </div>\n  );\n  // const timeString = time.toLocaleTimeString('en-US');\n  // return h('div', {}, h('h1', {}, 'The current time is: '), h('span', {}, timeString));\n}; */\n\nnew VirtualDOM(App).renderInto(document.querySelector('.todoapp'));\n","import './tree/component';\nimport { createNode } from './nodes/factory';\nimport { TreeNode } from './nodes/treeNode';\n\n/**\n * Constructor that enables the creation of a virtual DOM tree for the given component. This constructor can be called\n * multiple times on different components, there is no limit to the amount of virtual trees in a single page.\n *\n * @example\n * new VirtualDOM(App).renderInto(\"#app\");\n * @example\n * // You can also cache the tree for rendering in multiple locations\n * const app = new VirtualDOM(App);\n * app.renderInto(\"#app\");\n * app.renderInto(\"#other-app\");\n * @param root {TreeNode} - The component to render as the root of this tree.\n * @returns {{renderInto: renderInto}} Returns an object that can be chained to render this application into\n * multiple nodes.\n * @constructor\n * @export\n */\nexport function VirtualDOM(root) {\n  return {\n    /**\n     * Function that will render this application in the given HTMLElement.\n     * @param element {HTMLElement} - The element to use as the root of the application.\n     */\n    renderInto: element => {\n      if (typeof root !== 'function') {\n        throw new Error('The root of a virtual DOM tree must be a component');\n      }\n      const rootElement = document.createElement('vdom-component');\n      rootElement.factory = root;\n      rootElement.node = new TreeNode({ factory: root, children: [], attributes: {} });\n      rootElement.node.domNode = rootElement;\n      element.appendChild(rootElement);\n    },\n  };\n}\n\nexport { createNode as h };\n","/** @jsx h */\nimport { h } from '../../vdom';\n\nimport { Footer } from './footer';\nimport { TodoItem } from './todoItem';\nimport useTodoModel from '../model/todoModel';\n\nconst ALL_TODOS = 'all';\nconst ACTIVE_TODOS = 'active';\nconst COMPLETED_TODOS = 'completed';\n\nexport const App = (_, { todos = [], newTodo = '', nowShowing = ALL_TODOS, setState }) => {\n  const setNowShowing = val => setState('nowShowing', val);\n  const setNewTodo = val => setState('newTodo', val);\n  const setTodos = val => setState('todos', val);\n  const model = useTodoModel(todos, setTodos);\n\n  const handleChange = event => {\n    setNewTodo(event.target.value);\n  };\n\n  const handleNewTodoKeyDown = event => {\n    if (event.key !== 'Enter') {\n      return;\n    }\n\n    event.preventDefault();\n\n    const val = newTodo.trim();\n\n    if (val) {\n      model.addTodo(val);\n      setNewTodo('');\n    }\n  };\n\n  const allTodos = model.all();\n  const shownTodos = allTodos.filter(todo => {\n    switch (nowShowing) {\n      case ACTIVE_TODOS:\n        return !todo.completed;\n      case COMPLETED_TODOS:\n        return todo.completed;\n      default:\n        return true;\n    }\n  });\n\n  const activeTodoCount = allTodos.reduce((accum, todo) => todo.completed ? accum : accum + 1, 0);\n\n  const completedCount = allTodos.length - activeTodoCount;\n\n  return (\n    <div>\n      <header class=\"header\">\n        <h1>todos</h1>\n        <input\n          class=\"new-todo\"\n          placeholder=\"What needs to be done?\"\n          value={newTodo}\n          onkeydown={handleNewTodoKeyDown}\n          oninput={handleChange}\n          autoFocus={true}\n        />\n      </header>\n      {todos.length ? (\n        <section class=\"main\">\n          <input\n            id=\"toggle-all\"\n            class=\"toggle-all\"\n            type=\"checkbox\"\n            onchange={() => model.toggleAll(activeTodoCount !== 0)}\n            checked={activeTodoCount === 0}\n          />\n          <label\n            htmlFor=\"toggle-all\"\n          />\n          <ul class=\"todo-list\">\n            {shownTodos.map(todo => <TodoItem key={todo.id} todo={todo} model={model} />)}\n          </ul>\n        </section>\n      ) : null}\n      {(activeTodoCount || completedCount) ? (\n        <Footer\n          count={activeTodoCount}\n          completedCount={completedCount}\n          nowShowing={nowShowing}\n          setNowShowing={setNowShowing}\n          clearCompleted={() => model.toggleAll(false)}\n        />\n      ) : null}\n    </div>\n  );\n};\n"]}